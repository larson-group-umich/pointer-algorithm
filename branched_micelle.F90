!==================================================================
!                    SHARED PARAMETER
!==================================================================

	MODULE SHARED

	SAVE

	REAL :: STRPNT(90090,404),C3,C4,CNST_R,CNST_F,COEF_F,tMAX,tMIN
	REAL :: T(1000),G(1000),GF(1000),TAGET_MIU(40),INDEX,BDIND,DT,RANG
	REAL :: TAGET_TAO(40),PC,PM,Ls,STRINF(90090,5),FMAP(3030,5),Ld
	REAL :: MDTR2(3030,10),SDTR2(3030,10),SRINF(10,505,5),FDTR2(3030,5)
	REAL :: TRY_ERRG,TRY_MIU(40),TRY_TAO(40),INFERR1(505,5),INFERR2(505,5)
	REAL :: PNTERR1(505,404),PNTERR2(505,404)  

	INTEGER :: STRMAP(90090,20),LMAP(3030,15),NUMSTR,FUN,LSTRMAP,M
	INTEGER :: NUM,NLF,LLMAP,LINF,LFMAP,N,NUMG,NN,SAMPLE,GENERATION
	INTEGER :: NUMDTR(3),NSEED,TRY_NN,Nt0,SZMA,STRMA,NIND,SZERR1
	INTEGER :: SDTR1(3030,5),MDTR1(3030,5),FDTR1(3030,5),FUMDTR(5)
	INTEGER :: MAPERR1(505,20),MAPERR2(505,20),SZERR2
																	  
	END MODULE SHARED
													   
!==================================================================
!				         MAIN PROGRAM START
!==================================================================

	PROGRAM MAIN

    USE SHARED
    IMPLICIT DOUBLE PRECISION (A-H,O-Z)

    REAL :: Kb,La,TEM,Lp,PHI,tbr,trep,RATIO,Le,PI,G0,BR,W,D0,DW,Vs
	REAL :: RND,G2,ERRG,GG(1000),GGG(1000),ZETA,d,SMPNT1(505,1010),FIC
	REAL :: TL,tp,te,GGC,GGGC,SUMR1,WB,SMINF2(505,5),APH,ZE,FRL(2),LBAR
	REAL :: FIC2,G01,G02,WEI,SMINF3(505,5),ST,OS,SMPNT2(505,1010),LRL(3)
	REAL :: NBRL,RATIO_BD,tbud,VOF,SMPNT3(505,1010),BBL(3),NSTRAV,GGGS 	
	REAL :: SMINF1(505,5),FMMAP1(5),FMMAP2(5),BETA(3),PNBB(3),PNFR(3)
	REAL :: PNLR(3),MARK,BUD,NEND(3),NLNR(3),NBR(3),NBRP3(3),NBRP4(3)
	REAL :: LSGAV,EQL,EQB,CLENTH,G21,G22,GGS,LSEGAV,Kbr

    INTEGER :: I,J1,J2,K,KK,TT,III,JJJ,LPI(3),LBR,LREC1,LREC2,Z,LRSLU
	INTEGER :: LSEG,KKK,REM,SMMAP3(505,20),SIZ3,FLAGEQ,REMAIN,FLAGBK
	INTEGER :: NUMOU,PNLF,FLAGG,II,FLAG,NT,XCH,ISIZE,IDATE(8),OUTI
    INTEGER :: SUM1,SUM2,STAT,LSEGF,LBEND,LDR,LMMAP(15),LNUM,OUTE,RES
	INTEGER :: LROUSE,TTE,DISTR(3,20),LBUD,INV,TTA,OUTW,OUTGT,NUMAV
	INTEGER :: SMMAP1(505,20),SMMAP2(505,20),SIZ1,SIZ2,SUML,OUTMB
	INTEGER :: FLAGAZ,TTAMA,FLAGDEQ,NDEQ,FLAGSS

    INTEGER,ALLOCATABLE :: ISEED(:)
	CHARACTER :: TITLE,ANS1,ANS2,ANS3 
																									
!==================================================================
!				         INPUT PARAMETER
!==================================================================

 	Kb=1.381E-23                 ! BOLTZMANN CONSTANT
	PI=3.141592653   			 ! CONSTANT PI
	Vs=0.000891        		     ! SOLVENT VISCOSITY
    PHI=0.0662                   ! VOLUME FRACTION	
	TEM=298.15				     ! SYSTEMIC TEMPERATURE

    CALL DATE_AND_TIME(VALUES=IDATE)
    CALL RANDOM_SEED(SIZE=ISIZE)
    ALLOCATE(ISEED(ISIZE))
	ISEED=IDATE(2)+IDATE(3)+IDATE(4)
    ISEED=ISEED*(IDATE(6)+IDATE(5)+IDATE(7))
    CALL RANDOM_SEED(PUT=ISEED)

	FMA=5.						 ! THE ORDER OF MAXIMUM FREQUENCY OF EXPERIMENTAL DATA 
	FMI=-2.				    	 ! THE ORDER OF MINIMUM FREQUENCY OF EXPERIMENTAL DATA
	DTL=2*10.**(-6.)	    	 ! TIME STEP CONSTANT

	LDR=1						 ! THE SWITCHER FOR DOUBLE REPTATION
	LROUSE=1					 ! THE SWITCHER FOR ROUSE MODES
	LBEND=1						 ! THE SWITCHER FOR BENDING	MODES
	LRSLU=1						 ! THE SWITCHER FOR MICELLE GROUPING RESOLUTION 

	PC=0.75				         ! PROBABILITY OF PERMUTATION
	PM=0.2 	 		             ! PROBABILITY OF MUTATION
	GENERATION=20000 	         ! NUMBER OF GENERATION 
	PNLF=0.05			         ! MAXIMUM FLUCTUATION PERCENT OF MICELLE NUMBER
	NN=20					   	 ! APPROXIMATE PARAMETER NUMBER
	SAMPLE=2*NN			         ! NUMBER OF SAMPLE SIZE  
	NSEED=9 					 ! SEEDS NNUMBER 

	OUTGT=0						 ! THE SWITCHER FOR CREATING G(T)&GF(T) FILE
	OUTR=0						 ! THE SWITCHER FOR CREATING ROUSE MODES FILE
	OUTW=0						 ! THE SWITCHER FOR CREATING G(W) FILE
	OUTI=0						 ! THE SWITCHER FOR CREATING INITIATION FILE
	OUTE=0						 ! THE SWITCHER FOR CREATING EVOLUTION FILE
	OUTMB=0						 ! THE SWITCHER FOR CREATING EQUILIBRIUM FILE

 	FUN=4						 ! FUNCTIONALITY
    LLMAP=7						 ! THE WIDTH OF LMAP
	LINF=4						 ! THE WIDTH OF STRINF
	LFMAP=2						 ! THE WIDTH OF FMAP
	SZMA=100					 ! THE MAXIMUM SIZE OF STRMAP
	RANG=5.						 ! THE RANGE OF MICELLE STRAND DISTRIBUTION
 
	TT=10**8					 ! MAXIMUM TIME FOR RELAXATION 
	TTE=5*10**6					 ! TIME FOR EQUILIBRATION
	INV=10**4 			    	 ! OUTPUT INTERVAL
	INDEX=0.01 					 ! DATA RECORDING INTERVAL
!	INV=1
	TTAMA=25	 				 ! TIME STEP FOR AVERAGING DISTRIBUTION
	JJJ=0
	KKK=0						 ! TESTING NUMBER

	NUM=2000					 ! ENSEMBLE SIZE
	NLF=0						 ! FLUCTUATION OF NUMBE OF MICELLES
	LSEG=0						 ! NUMBER OF SEGMENT IN ENSEMBLE
	LSEGF=0.					 ! FLUCTUATION OF NUMBE OF SEGMENTS
	NUMSTR=0					 ! NUMBER OF STRAND		 

	NUMOU=500					 ! NUMBER OF OUTPUT DATA 
	DW=(FMA-FMI)/NUMOU			 ! INTERVAL OF FREQUENCY
	REM=0			  			 ! ROUND OF RECORDED TOTAL SIMULATION TIME STEP

	FLAGG=0						 ! FLAG FOR FIXING TAO_I FOR GA
	Ls=1.0						 ! THE RATIO OF SEGMENTAL LENGTH TO Lp
    FLAGSS=0					 ! FLAG FOR STARTING SIMULATION FROM SPECIFIED PARAMETER VALUE

    OPEN(20,FILE='OUTPUT.DAT')	 ! PARAMETER AND FITTING ERROR EVOLUTION OUTPUT FILE
	OPEN(23,FILE='TIME_FREQUENCY TRANSFORMATION.DAT')	! MIU_I&TAO_I OUTPUT FILE 
	OPEN(24,FILE='SIMULATION MONITOR.DAT')  ! PROCESSION OF SIMULATION OUTPUT FILE

	OPEN(27,FILE='NEVOL1.DAT')
	OPEN(28,FILE='NEVOL2.DAT')
	OPEN(29,FILE='WEVOL1.DAT')
	OPEN(30,FILE='WEVOL2.DAT')

	OPEN(32,FILE='MDISTR.DAT')
	OPEN(33,FILE='SDISTR.DAT')
	OPEN(34,FILE='DTLINFO.DAT')
	OPEN(35,FILE='BRESULT.DAT')			
 	OPEN(36,FILE='FDISTR.DAT') 
					
!==================================================================
!				         READING INPUT FILE
!==================================================================
											 
	OPEN(16,FILE='INPUT_BRANCH.DAT')	! EXPERIMENTAL DATA INPUT FILE
	READ(16,*) TITLE
	READ(16,*) TEM,PHI,Vs

	READ(16,*) ANS1,ANS2,ANS3
	IF (ANS1.EQ.'Y') THEN
	OUTGT=1
	END IF
 	IF (ANS2.EQ.'Y') THEN
	OUTW=1
	END IF
	IF (ANS3.EQ.'Y') THEN
	OUTR=1
	END IF

	READ(16,*) ANS1
	IF (ANS1.EQ.'Y') THEN
	OUTMB=1
	END IF

	READ(16,*) ANS1,ANS2,ANS3
	IF (ANS1.EQ.'Y') THEN
	OUTI=1
	END IF
 	IF (ANS2.EQ.'Y') THEN
	OUTE=1
	END IF
	IF (ANS3.EQ.'M') THEN
	LRSLU=0
	END IF
	IF (ANS3.EQ.'L') THEN
	LRSLU=-1
	END IF

	READ(16,*) RATIO,ZE,APH
	READ(16,*) RATIO_BD,Lp,d
	READ(16,*) NUM,FUN

	READ(16,*) ANS1,Kbr,tbud
	IF (ANS1.EQ.'Y') THEN
	FLAGSS=1
	END IF

	CLOSE(16)

	Lp=Lp*10**(-9.)		         ! PERSISTENT LENGTH 
	d=d*10**(-9.)			     ! MICELLE DIAMETER
	LSTRMAP=2*FUN+1				 ! THE WIDTH OF STRMAP					        
	Ld=2.0*d/(Ls*Lp)				 ! THE RATIO OF BUD LENGTH TO SEGMENTAL LENGTH
			 
    TL=SQRT(APH/2.)	             ! RATIO OF MICELLE LENGTH TO TUBE LENGTH 
	IF (APH.LT.2) THEN
	TL=1.
	END IF 
    La=ZE*Lp*APH/TL		         ! AVERAGE TUBE LENGTH
       
	Le=APH*Lp    	             ! ENTANGLEMENT LENGTH 
	ZETA=Le**0.6*Lp**0.4         ! MESH SIZE
    WEI=APH**3/(APH**3+3.)
	G01=9.75*Kb*TEM/ZETA**3	         ! PLATEAU MODULUS FOR LOOSELY-ENTANGLED 
    G02=28./5./PI*Kb*TEM*PHI/d**2./Le !	PLATEAU MODULUS FOR TIGHTLY-ENTANGLED
    G0=G01*WEI+G02*(1.-WEI)		 ! PLATUAE MODULUE
	LBAR=La/Lp			         ! RATIO OF TUBE LENGTH TO Lp
	FIC=2.*PI*Vs/LOG(ZETA/d)	 ! PARALLEL FRICTION COEFFICIENT 
	D0=Kb*TEM/FIC				 ! MOBILITY OF MICELLE
    trep=La**3./D0/PI**2.*TL	 ! REPTATION TIME

	IF (FLAGSS.EQ.0) THEN
	tbud=RATIO_BD*trep			 ! BUDDING TIME
	tbr=RATIO*trep				 ! BREAKAGE TIME
	Kbr=1./(La*TL*tbr)			 ! BREAKAGE RATE
	ELSE
	tbr=1./(La*TL*Kbr)
	RATIO=tbr/trep
	RATIO_BD=tbud/trep
	END IF	
			
	te=Le**3./(TL*PI)**2./D0	 ! EQUILIBRATION TIME
    FIC2=4.*PI*Vs/LOG(0.6*ZETA/d)  ! PERPENDICULAR FRICTION COEFFICIENT
	tp=2*Lp**(5./3.)*FIC2/Kb/TEM   ! BENDING TIME
	ST=0.3827*Kb*TEM*tp**0.75/15./PI*4.*d**(-2.)*PHI ! BENDING MODES COEFFICIENT FOR G'
	OS=0.9239/0.3827*ST          ! BENDING MODES COEFFICIENT FOR G"

    WRITE(20,*) 'PLATEAU:',G0
    WRITE(20,*) 'RATIO:',RATIO
    WRITE(20,*) 'BUD:',RATIO_BD
	WRITE(20,*)	'Trep:',trep
	WRITE(20,*)	'Ze:',ZE   
	WRITE(20,*) 'MICELLE LENGTH:',La*TL
    WRITE(20,*) 'ALPHA:',APH
    WRITE(20,*) 'PERSISTENCE:',Lp
    WRITE(20,*) 'DIAMETER:',d

    WRITE(*,*) 'PLATEAU:',G0
    WRITE(*,*) 'RATIO:',RATIO
    WRITE(*,*) 'BUD:',RATIO_BD
	WRITE(*,*)	'Trep:',trep
	WRITE(*,*)	'Ze:',Ze
    WRITE(*,*) 'MICELLE LENGTH:',La*TL
    WRITE(*,*) 'ALPHA:',APH
    WRITE(*,*) 'PERSISTENCE:',Lp
    WRITE(*,*) 'DIAMETER:',d

!==================================================================
!			     LINEAR ENSEMBLE INITIATION PART
!==================================================================

 	IF (OUTGT.EQ.1) THEN	 ! WRITE OUTPUT FILE FOR FITTED G(t) GENERATE BY GA
 	OPEN(17,FILE='GT.DAT')	  
	END IF	
	IF (OUTW.EQ.1) THEN		 ! WRITE OUTPUT FILE FOR CONVERTED G(W) GENERATE BY GA
 	OPEN(18,FILE='GW.DAT')	  
	END IF
 	IF (OUTR.EQ.1) THEN		 ! WRITE OUTPUT FILE FOR G'&G" BY ROUSE MODES
 	OPEN(21,FILE='ROUSE.DAT')	  
	END IF

	DT=tbr/NUM/2.
	IF (DT.GT.DTL) THEN
	DT=DTL
	END IF

	N=7							 ! *CHANGES FROM 1 TO 2 ! INTERVAL OF DISCRETIZED MICELLE TUBE LENGTH
	Ls=EXP(RANG)/NUM*LBAR
	M=CEILING(RANG*LBAR/Ls/N)	 ! MAXIMUM LENGTH IN THE ENSEMBLE
  	DO J=1,10000
  	SUM1=0
    DO I=1,M				     ! GENERATE MICELLE FOLLOWED BY ITS LENGTH DISTRIBUTION
    SUM1=SUM1+CEILING(NUM*N*Ls/LBAR/EXP(I*N*Ls/LBAR))
	END DO
	REMAIN=SUM1-NUM	
    IF (ABS(REMAIN).LE.1) THEN	 		 
	EXIT
	ELSE
	Ls=Ls/NUM*SUM1
    M=CEILING(RANG*LBAR/Ls/N)
    END IF			
	END DO

21  WRITE(24,*) 'LINEAR LENGTH DISCRETIZATION FINISH'
	WRITE(*,*) 'LINEAR LENGTH DISCRETIZATION FINISH'

	WRITE(24,*) 'THE SEGMENTAL LENGTH IS',Lp*Ls
	WRITE(24,*) 'THE MAXIMUM TUBE LENGTH IS',M*N*Lp*Ls
	WRITE(*,*) 'THE SEGMENTAL LENGTH IS',Lp*Ls
	WRITE(*,*) 'THE MAXIMUM TUBE LENGTH IS',M*N*Lp*Ls

!	RANG=M*N*Ls/LBAR
	SZMA=FUN
	STRMA=M*N

	SUML=0
	NBRL=0

	SUM2=0
	DO I=1,M
	LNUM=CEILING(NUM*N*Ls/LBAR/EXP(I*N*Ls/LBAR))
	IF ((I.EQ.M).AND.(SUM2+LNUM.NE.NUM)) THEN
	LNUM=NUM-SUM2
	END IF

!	WRITE(37,*) I,I*N, LNUM
	SUM1=1+SUM2
    SUM2=SUM2+LNUM		
	DO J=SUM1,SUM2
	LMAP(J,1)=0
	LMAP(J,2)=I*N
	LMAP(J,3)=0
	LMAP(J,4)=0
	LMAP(J,5)=2
	LMAP(J,6)=1
	LMAP(J,7)=J
	FMAP(J,1)=0.
	FMAP(J,2)=0.
	LSEG=LSEG+LMAP(J,2)
	END DO

	DO J=SUM1,SUM2
	DO K=1,2*(FUN-1)
	STRMAP(J,K)=0
	END DO
	STRMAP(J,2*FUN-1)=1
	STRMAP(J,2*FUN)=LMAP(J,2)
	STRMAP(J,2*FUN+1)=0
	STRINF(J,1)=0.
 	STRINF(J,2)=1.
	STRINF(J,3)=-1.
	STRINF(J,4)=-1.
	NUMSTR=NUMSTR+1
	END DO
	END DO

	IF (OUTI.EQ.1) THEN
    CALL LDSTB(0)
	OPEN(25,FILE='MICELLE INITIATION.DAT')	 ! INITIAL MICELLE SIZE DISTRIBUTION FILE
	OPEN(26,FILE='STRAND INITIATION.DAT')	 ! INITIAL STRAND SIZE DISTRIBUTION FILE
	WRITE(25,*)	'SEGMENTAL LENGTH: ',Ls*Lp
	DO I=1,NUMDTR(1)
	WRITE(25,*)	MDTR1(I,1),MDTR1(I,2),MDTR2(I,1),MDTR2(I,2)
	END DO

 	WRITE(26,*)	'SEGMENTAL LENGTH: ',Ls*Lp
	DO I=1,NUMDTR(2)
	WRITE(26,*)	SDTR1(I,1),SDTR1(I,2),SDTR2(I,1),SDTR2(I,2),SDTR2(I,3)
	END DO
	CLOSE(25)
	CLOSE(26)
	END IF

	NBR=0.					! NUMBER OF BRANCH MICELLE
	NLNR=0.					! NUMBER OF LINEAR MICELLE
	NEND=0.					! NUMBER OF MICELLE	END
	NBRP3=0.				! NUMBER OF Y JUNCTION
	NBRP4=0.				! NUMBER OF + JUNCTION
	DO I=1,NUM+NLF
	NBRP3(1)=NBRP3(1)+LMAP(I,3)
	NBRP4(1)=NBRP4(1)+LMAP(I,4)
	NEND(1)=NEND(1)+LMAP(I,5)
	NBR(1)=NBR(1)+LMAP(I,1)
	NLNR(1)=NLNR(1)+1-LMAP(I,1)
	END DO

!	CLOSE(37)
	WRITE(24,*) 'LINEAR CHAIN LIST INITIATION FINISH'
	WRITE(*,*) 'LINEAR CHAIN LIST INITIATION FINISH'

!==================================================================
!				     ENSEMBLE EQUILIBRIATION
!==================================================================
	
	WRITE(27,*) 'TIME STEP: ',DT
	WRITE(28,*) 'TIME STEP: ',DT
	WRITE(29,*) 'TIME STEP: ',DT
	WRITE(30,*) 'TIME STEP: ',DT

	FLAGEQ=0			   ! FLAG FOR POINTER ALGORITHM
	FLAGAZ=0			   ! FLAG FOR ANALYSIS STARTING
	FLAGDEQ=0			   ! FLAG FOR EQUILIBRIUM DETECTION 

	NDEQ=0				   ! NUMBER OF DETECTED EQUILIBRIUM POINTS
	TTA=0
	NSTRAV=0.			   ! AVERAGE NUMBER OF STRAND
	LSGAV=0.			   ! AVERAGE NUMBER OF SEGMENTS
	BETA=0.				   ! NUMBER OF BRANCHED POINTSN PER	MICRON OF MICELLE
	PNLR=0.				   ! NUMBER PERCENTAGE OF LINEAR MICELLE
	PNFR=0.				   ! NUMBER PERCENTAGE OF FREE ARM
	PNBB=0.				   ! NUMBER PERCENTAGE OF BACKBONE
	LRL=0.				   ! AVERAGE SIZE OF LINEAR MICELLE
	FRL=0.				   ! AVERAGE SIZE OF FREE ARM
	BBL=0.				   ! AVERAGE SIZE OF BACKBONE
	NUMAV=0

    CNST_R=2*D0*DT/(Lp*Ls)**3./TL
    CNST_F=2.*(CNST_R*TL/3./PI/Ls)**0.25
	COEF_F=4.*CNST_R*TL/3./PI/Ls
											   
	C3=SQRT(6*Kb*TEM*DT/FIC/(Lp*Ls)**3./TL)	 ! *CHANGE FROM FACTOR FROM 2 TO 6
	C4=100.*Kb*TEM*DT/Lp/FIC/(Lp*Ls)**2./TL	 ! *

	IF (OUTMB.EQ.1) THEN
	TTE=1
	TTAMA=1
	END IF

	MARK=0.01*trep/DT/NUM/2.
	BUD=tbud/DT/NUM

A01:DO I=1,TTE

	IF (I.EQ.1) THEN
	J1=0
	J2=0
	END IF

!	IF (I.LE.10*INV) THEN
!	BUD=MARK*0.05
!	ELSE
!	BUD=tbud/DT/NUM
!	END IF

!   BUDDING START

B01:DO WHILE (I.GT.J1*BUD)
	J1=J1+1

31	CALL RANDOM_NUMBER(RND)
	LBUD=INT(RND*(LSEG+LSEGF))
	IF (LBUD.LT.1) THEN
	GOTO 31
	END IF

	DO K=1,NUM+NLF
	IF (LBUD.EQ.0) THEN
	LPI(1)=K
	EXIT
	END IF
	LBUD=LBUD-LMAP(K,2)						
	IF (LBUD.LT.0) THEN	
	LBUD=LBUD+LMAP(K,2)
	LPI(1)=K
	EXIT
	END IF
	END DO 

	CALL EXTR_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	SIZ1=LMAP(LPI(1),6)	

!	SZERR1=SIZ1
!	MAPERR1=SMMAP1
!	INFERR1=SMINF1
!	PNTERR1=SMPNT1

	CALL UPDT_LST(FLAGEQ,LPI(1))
	STAT=0
	CALL BUDDING(FLAGEQ,LBUD,SIZ1,SMMAP1,SMINF1,SMPNT1,SIZ2,SMMAP2,SMINF2,SMPNT2,STAT)

!	SZERR2=SIZ2
!	MAPERR2=SMMAP2
!	INFERR2=SMINF2
!	PNTERR2=SMPNT2

	IF (STAT.LT.0) THEN
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	GOTO 31
	ELSE
    CALL RODR_STR(FLAGEQ,SIZ2,SMMAP2,SMINF2,SMPNT2,SMMAP1,SMINF1,SMPNT1)
	SIZ1=SIZ2
    CALL RFMAP(SIZ1,SMMAP1,SMINF1,LMMAP,FMMAP1,SMINF2)
	DO II=1,6
	LMAP(LPI(1),II)=LMMAP(II)
	END DO
	FMAP(LPI(1),2)=FMMAP1(2)
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF2,SMPNT1)

! 	CALL TSER(FLAGEQ,SIZ1,SMMAP1,SMINF2,SMPNT1,STAT)
!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'BUDDING PROBLEM'
!	CALL PTER(FLAGEQ,0,SZERR1,MAPERR1,INFERR1,PNTERR1)
!	CALL PTER(FLAGEQ,1,SZERR2,MAPERR2,INFERR2,PNTERR2)
!   CALL PTER(FLAGEQ,2,SIZ1,SMMAP1,SMINF2,SMPNT1)
!	PAUSE
!	END IF

	END IF

	END DO B01

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP BUDDING FINISH, NUMSTR:',NUMSTR
	WRITE(*,*) I,' STEP BUDDING FINISH, NUMSTR:',NUMSTR 
	END IF

!   MICELLE BREAKAGE & REJOINING START

	SUM1=0
	NEND(1)=0.
	DO K=1,NUM+NLF
	SUM1=SUM1+LMAP(K,2)
	NEND(1)=NEND(1)+LMAP(K,5)
	END DO
	LSEGF=SUM1-LSEG

B11:IF (I.GT.J2*MARK) THEN

	J2=J2+1
	CALL RANDOM_NUMBER(BR)
	IF (NLF.LT.(-1)*PNLF*NUM) THEN
	BR=0.25
	END IF
	IF (NLF.GT.PNLF*NUM) THEN
	BR=0.75
	END IF

!	CALL BKINF(KK,XCH,FLAGBK) ! *
!	IF (FLAGBK.LT.0) THEN	  ! *
!	BR=0.25					  ! *
!	END IF					  ! *

C11:IF (BR.LT.0.5) THEN

!32  CALL BKINF(LPI(1),LBR,FLAGBK)	! *
!    IF (FLAGBK.GT.0) THEN ! *

32  CALL RANDOM_NUMBER(RND)
	LBR=INT(RND*(LSEG+LSEGF))

	DO K=1,NUM+NLF
	IF (LBR.EQ.0) THEN
	LPI(1)=K
	EXIT
	END IF
	LBR=LBR-LMAP(K,2)					
	IF (LBR.LT.0) THEN		
	LBR=LBR+LMAP(K,2)
	LPI(1)=K
	EXIT
	END IF
	END DO

!	END IF ! *

	CALL EXTR_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	CALL UPDT_LST(FLAGEQ,LPI(1))
	SIZ1=LMAP(LPI(1),6)

!	SZERR1=SIZ1
!	MAPERR1=SMMAP1
!	INFERR1=SMINF1
!	PNTERR1=SMPNT1

	STAT=0
	CALL BRKG(FLAGEQ,LBR,SIZ1,SMMAP1,SMINF1,SMPNT1,SIZ2,SMMAP2,SMINF2,SMPNT2,&
	&SIZ3,SMMAP3,SMINF3,SMPNT3,STAT)

	IF (STAT.LT.0) THEN
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	GOTO 32
	ELSE
	CALL RNFM_STR(FLAGEQ,SIZ2,SMMAP2,SMINF2,SMPNT2,SIZ1,SMMAP1,SMINF1,SMPNT1)
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP2,SMINF2,SMPNT2)	
	SIZ2=SIZ1
    CALL RFMAP(SIZ2,SMMAP2,SMINF2,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(LPI(1),II)=LMMAP(II)
	END DO
	FMAP(LPI(1),2)=FMMAP1(2)
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP2,SMINF1,SMPNT2)

!	SZERR2=SIZ2
!	MAPERR2=SMMAP2
!	INFERR2=SMINF1
!	PNTERR2=SMPNT2

! 	CALL TSER(FLAGEQ,SIZ2,SMMAP2,SMINF1,SMPNT2,STAT)
!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'BREAKAGE PROBLEM 1'
!	CALL PTER(FLAGEQ,0,SZERR1,MAPERR1,INFERR1,PNTERR1)
!	CALL PTER(FLAGEQ,1,SIZ2,SMMAP2,SMINF1,SMPNT2)
!	PAUSE
!	END IF

	CALL RNFM_STR(FLAGEQ,SIZ3,SMMAP3,SMINF3,SMPNT3,SIZ1,SMMAP1,SMINF1,SMPNT1)
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP3,SMINF3,SMPNT3)
	SIZ3=SIZ1
    CALL RFMAP(SIZ3,SMMAP3,SMINF3,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(NUM+NLF+1,II)=LMMAP(II)
	END DO
 	FMAP(NUM+NLF+1,2)=FMMAP1(2)
 	FMAP(NUM+NLF+1,1)=FMAP(LPI(1),1)  ! *
	CALL INST_STR(FLAGEQ,NUM+NLF+1,SMMAP3,SMINF1,SMPNT3)

	NLF=NLF+1

!	CALL TSER(FLAGEQ,SIZ3,SMMAP3,SMINF1,SMPNT3,STAT)
!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'BREAKAGE PROBLEM 2'
!	CALL PTER(FLAGEQ,0,SZERR1,MAPERR1,INFERR1,PNTERR1)
!	CALL PTER(FLAGEQ,1,SZERR2,MAPERR2,INFERR2,PNTERR2)
!	CALL PTER(FLAGEQ,2,SIZ3,SMMAP3,SMINF1,SMPNT3)
!	PAUSE
!	END IF

	END IF

	ELSE

33  CALL RANDOM_NUMBER(RND)
	LREC1=INT(RND*NEND(1))
    CALL RANDOM_NUMBER(RND)
	LREC2=INT(RND*NEND(1))

	IF ((LREC1.LT.1).OR.(LREC2.LT.1)) THEN
	GOTO 33
	END IF
	IF (LREC1.EQ.LREC2) THEN
	GOTO 33
	END IF

    DO K=1,NUM+NLF
	LREC1=LREC1-LMAP(K,5)
	IF (LREC1.LE.0) THEN
	LREC1=LREC1+LMAP(K,5)
	LPI(1)=K
	EXIT
	END IF
	END DO 
    DO K=1,NUM+NLF
	LREC2=LREC2-LMAP(K,5)
	IF (LREC2.LE.0) THEN
	LREC2=LREC2+LMAP(K,5)
	LPI(2)=K
	EXIT
	END IF
	END DO 

	IF (LPI(1).EQ.LPI(2)) THEN
	GOTO 33
	END IF

	SUM1=LMAP(LPI(1),6)+LMAP(LPI(2),6)
	IF (SUM1.GT.SZMA) THEN
	GOTO 33
	END IF

	CALL EXTR_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	SIZ1=LMAP(LPI(1),6)

!	SZERR1=SIZ1
!	MAPERR1=SMMAP1
!	INFERR1=SMINF1
!	PNTERR1=SMPNT1

	CALL UPDT_LST(FLAGEQ,LPI(1))
	CALL EXTR_STR(FLAGEQ,LPI(2),SMMAP2,SMINF2,SMPNT2)
	SIZ2=LMAP(LPI(2),6)

!	SZERR2=SIZ2
!	MAPERR2=SMMAP2
!	INFERR2=SMINF2
!	PNTERR2=SMPNT2

	CALL UPDT_LST(FLAGEQ,LPI(2))

	STAT=0
	CALL REJN(FLAGEQ,LREC1,SIZ1,SMMAP1,SMINF1,SMPNT1,LREC2,SIZ2,SMMAP2,SMINF2,&
	&SMPNT2,SIZ3,SMMAP3,SMINF3,SMPNT3,STAT)

	IF (STAT.LT.0) THEN
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	CALL INST_STR(FLAGEQ,LPI(2),SMMAP2,SMINF2,SMPNT2)
	GOTO 33
	ELSE
	CALL RNFM_STR(FLAGEQ,SIZ3,SMMAP3,SMINF3,SMPNT3,SIZ1,SMMAP1,SMINF1,SMPNT1)
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP3,SMINF3,SMPNT3)
	SIZ3=SIZ1
    CALL RFMAP(SIZ3,SMMAP3,SMINF3,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(LPI(1),II)=LMMAP(II)
	END DO
	FMAP(LPI(1),2)=FMMAP1(2)
	FMAP(LPI(1),1)=0.5*(FMAP(LPI(1),1)+FMAP(LPI(2),1)) ! *
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP3,SMINF1,SMPNT3)

	CALL RFLM(LPI(2))
	NLF=NLF-1

!	CALL TSER(FLAGEQ,SIZ3,SMMAP3,SMINF1,SMPNT3,STAT)
! 	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'REJOIN PROBLEM'
!	CALL PTER(FLAGEQ,0,SZERR1,MAPERR1,INFERR1,PNTERR1)
!	CALL PTER(FLAGEQ,1,SZERR2,MAPERR2,INFERR2,PNTERR2)
!	CALL PTER(FLAGEQ,2,SIZ3,SMMAP3,SMINF1,SMPNT3)
!	PAUSE
!	END IF

	END IF

	END IF C11

	END IF B11

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP BRKG&REJN FINISH, NLF:',NLF
	WRITE(*,*) I,' STEP BRKG&REJN FINISH, NLF:',NLF 
	END IF

!   FLUIDITY OF MICELLE BRANCH POINT START

B21:DO K=1,NUM+NLF
	IF (LMAP(K,1).NE.0)	THEN

	CALL EXTR_STR(FLAGEQ,K,SMMAP1,SMINF1,SMPNT1)
	CALL UPDT_LST(FLAGEQ,K)							  
	SIZ1=LMAP(K,6)
	FMMAP1(1)=FMAP(K,1)
!	CALL PTER(FLAGEQ,0,SIZ1,SMMAP1,SMINF1,SMPNT1)

	FLAG=1
	DO WHILE (FLAG.EQ.1)
	
!	SZERR1=SIZ1
!	MAPERR1=SMMAP1
!	INFERR1=SMINF1
!	PNTERR1=SMPNT1
!	CALL PTER(FLAGEQ,1,SZERR1,MAPERR1,INFERR1,PNTERR1)
    CALL DISP(FLAGEQ,FMMAP1,SIZ1,SMMAP1,SMINF1,SMPNT1,FMMAP2,SIZ2,SMMAP2,SMINF2,SMPNT2)

!	SZERR2=SIZ2
!	MAPERR2=SMMAP2
!	INFERR2=SMINF2
!	PNTERR2=SMPNT2
!	CALL PTER(FLAGEQ,2,SZERR2,MAPERR2,INFERR2,PNTERR2)
	CALL RNFM_STR(FLAGEQ,SIZ2,SMMAP2,SMINF2,SMPNT2,SIZ1,SMMAP1,SMINF1,SMPNT1)
	
!	CALL PTER(FLAGEQ,3,SIZ1,SMMAP1,SMINF1,SMPNT1)
!	CALL TSER(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,STAT)
!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'FLUIDITY PROBLEM 1'
!	CALL PTER(FLAGEQ,0,SZERR1,MAPERR1,INFERR1,PNTERR1)
!	CALL PTER(FLAGEQ,1,SZERR2,MAPERR2,INFERR2,PNTERR2)
!	CALL PTER(FLAGEQ,2,SIZ1,SMMAP1,SMINF1,SMPNT1)
!	PAUSE
!	END IF
!	SZERR2=SIZ1
!	MAPERR2=SMMAP1
!	INFERR2=SMINF1
!	PNTERR2=SMPNT1

	IF (FMMAP2(1).LT.1.) THEN
	FLAG=0
	ELSE
	FMMAP1(1)=FMMAP2(1)-1.
	END IF
	END DO

	FMAP(K,1)=FMMAP2(1)
!	CALL PTER(FLAGEQ,4,SIZ1,SMMAP1,SMINF1,SMPNT1)	 
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP2,SMINF2,SMPNT2) 
	SIZ2=SIZ1
    CALL RFMAP(SIZ2,SMMAP2,SMINF2,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(K,II)=LMMAP(II)
	END DO
	FMAP(K,2)=FMMAP1(2)
	CALL INST_STR(FLAGEQ,K,SMMAP2,SMINF1,SMPNT2)

!	CALL PTER(FLAGEQ,5,SIZ2,SMMAP2,SMINF1,SMPNT2)
!	CALL TSER(FLAGEQ,SIZ2,SMMAP2,SMINF1,SMPNT2,STAT)
!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'FLUIDITY PROBLEM 2'
!	CALL PTER(FLAGEQ,0,SZERR1,MAPERR1,INFERR1,PNTERR1)
!	CALL PTER(FLAGEQ,1,SZERR2,MAPERR2,INFERR2,PNTERR2)
!	CALL PTER(FLAGEQ,2,SIZ2,SMMAP2,SMINF1,SMPNT2)
!	PAUSE
!	END IF

	ELSE

	FMAP(K,1)=0.

	END IF
	END DO B21

	SUM1=0
	DO K=1,NUM+NLF
	SUM1=SUM1+LMAP(K,2)
	END DO
	LSEGF=SUM1-LSEG

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP FLUIDITY FINISH, LSEGF:',LSEGF 
	WRITE(*,*) I,' STEP FLUIDITY FINISH, LSEGF:',LSEGF
	END IF

!   DATA RECORDING

 	SUM1=0
	NBR(1)=0.					
	NLNR(1)=0.					
	NEND(1)=0.				
	NBRP3(1)=0.				
	NBRP4(1)=0.				
	DO K=1,NUM+NLF
	SUM1=SUM1+LMAP(K,2)
	NBRP3(1)=NBRP3(1)+LMAP(K,3)
	NBRP4(1)=NBRP4(1)+LMAP(K,4)
	NEND(1)=NEND(1)+LMAP(K,5)
	NBR(1)=NBR(1)+LMAP(K,1)
	NLNR(1)=NLNR(1)+1-LMAP(K,1)
	END DO
	LSEGF=SUM1-LSEG

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP EQUILIBRATION FINISH, NBRP3&4:',NBRP3(1),NBRP4(1) 
	WRITE(*,*) I,' EQUILIBRATION FINISH, NBRP3&4:',NBRP3(1),NBRP4(1)
	END IF


B31:IF (OUTE.EQ.1) THEN

	DISTR=0
	RES=1
	IF (LRSLU.EQ.0) THEN
	RES=2
	END IF
	IF (LRSLU.EQ.-1) THEN
	RES=3
	END IF

    DO K=1,NUM+NLF
	IF (LMAP(K,1).EQ.0)	THEN
	DISTR(1,1)=DISTR(1,1)+1
	DISTR(2,1)=DISTR(2,1)+LMAP(K,2) 
    ELSE
	SUM1=LMAP(K,3)+LMAP(K,4)
	FLAG=10
	DO II=1,9
	IF ((SUM1.GT.RES*(II-1)).AND.(SUM1.LE.RES*II)) THEN
	FLAG=II
	EXIT
	END IF
	END DO
	DISTR(1,FLAG+1)=DISTR(1,FLAG+1)+1			 ! *
	DISTR(2,FLAG+1)=DISTR(2,FLAG+1)+LMAP(K,2)	 ! *
	END IF
	END DO 

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(27,*)	I,DISTR(1,1:5)
	WRITE(28,*)	DISTR(1,6:11)
	WRITE(29,*)	I,DISTR(2,1:5)
	WRITE(30,*)	DISTR(2,6:11)
	END IF

	END IF B31
    
	BETA(1)=(NBRP3(1)+NBRP4(1))/(LSEG+LSEGF)/(Ls*Lp*10.**6.)	  
	PNLR(1)=NLNR(1)/NUMSTR
	LRL(1)=0.
	FRL(1)=0.
	PNFR(1)=0.
	BBL(1)=0.
	PNBB(1)=0.
		
	DO K=1,NUMSTR
	IF (STRINF(K,2).GT.0.) THEN
	LRL(1)=LRL(1)+(STRMAP(K,2*FUN)+STRINF(K,1))/NLNR(1)
	END IF
	IF (STRINF(K,3).GT.0.) THEN
	FRL(1)=FRL(1)+STRMAP(K,2*FUN)+STRINF(K,1)	 
	PNFR(1)=PNFR(1)+1./NUMSTR
	END IF
	IF (STRINF(K,4).GT.0.) THEN
	BBL(1)=BBL(1)+STRMAP(K,2*FUN)+STRINF(K,1)
	PNBB(1)=PNBB(1)+1./NUMSTR
	END IF
	END DO

	IF (PNFR(1).NE.0) THEN
	FRL(1)=FRL(1)/PNFR(1)/NUMSTR
	ELSE
	FRL(1)=0.
	END IF
	IF (PNBB(1).NE.0) THEN
	BBL(1)=BBL(1)/PNBB(1)/NUMSTR
	ELSE
	BBL(1)=0.
	END IF

 	SZMA=1+(FUN-1)*CEILING(BETA(1)*LBAR*Lp*10.**6.*TL*RANG)
	IF (SZMA.LT.FUN) THEN
	SZMA=FUN
!	SZMA=CEILING(RANG*(FUN-1)+1)
	END IF
	STRMA=CEILING(M*N/(1.+(FUN-1)*FLOOR(BETA(1)*LBAR*Lp*10.**6.*TL)))
!	STRMA=CEILING((LRL(1)+FRL(1)+BBL(1))/3.*RANG*(FUN-1))
	DO III=1,NUMSTR	! *				 
	IF (CEILING(STRMAP(III,2*FUN)+STRINF(III,1)).GT.STRMA) THEN ! *
	STRMA=CEILING(STRMAP(III,2*FUN)+STRINF(III,1))	! *
!	FLAG=0
!	DO JJJ=1,2*FUN-2 ! *
!	IF (STRMAP(III,JJJ).NE.0) THEN
!	FLAG=FLAG+1
	END IF
	END DO
!	IF ((FLAG.LE.FUN-1).AND.(FLAG.GT.0)) THEN
!	WRITE(*,*) 'DANGLING: ',STRMA
!	PAUSE
!	END IF
!	END IF
!	END DO
!	SUM1=STRMA			! *
!	DO III=1,NUMSTR	    ! *				 
!	IF (CEILING(STRMAP(III,2*FUN)+STRINF(III,1)).GT.SUM1) THEN ! *
!	SUM1=CEILING(STRMAP(III,2*FUN)+STRINF(III,1))	! *
!	END IF
!	END DO
!	IF (SUM1.LT.STRMA) THEN
!	STRMA=SUM1
!	END IF


B41:IF (MOD(I,INV).EQ.0) THEN
	SUMR1=(LRL(1)+FRL(1)+BBL(1))/3.	! *

	IF ((FLAGDEQ.EQ.0).AND.(I.GT.5*10**5)) THEN
!	SUMR1=(LRL(1)+FRL(1)+BBL(1))/3.
	IF (ABS(LRL(1)/SUMR1-1.).LE.0.075) THEN
	IF (ABS(FRL(1)/SUMR1-1.).LE.0.075) THEN
	IF (ABS(BBL(1)/SUMR1-1.).LE.0.075) THEN
	FLAGDEQ=1
	NDEQ=1
	EQB=BETA(1)
	EQL=SUMR1
	END IF
	END IF
	END IF
	ELSE
	EQB=EQB+BETA(1)
	EQL=EQL+SUMR1
	NDEQ=NDEQ+1
	END IF

	IF (FLAGDEQ.EQ.1) THEN
!	SUMR1=(LRL(1)+FRL(1)+BBL(1))/3.
	IF (NDEQ.LE.TTAMA) THEN
	IF ((ABS(SUMR1*NDEQ/EQL-1.).GT.0.075).OR.(ABS(BETA(1)*NDEQ/EQB-1.).GT.0.075)) THEN
	FLAGDEQ=0
	END IF
	ELSE
 	FLAGAZ=1
	END IF
	END IF

 	IF (I.GE.TTE*3/5) THEN	 ! *
	IF (BETA(1)*LBAR*Lp*10.**6.*TL.LE.0.5) THEN	! *
	FLAGAZ=1			 ! *
	END IF				 ! *
	END IF				 ! *

	IF (FLAGAZ.EQ.1) THEN
	TTA=TTA+1
	END IF
	END IF B41

!	IF (FLAGAZ.EQ.1) THEN
!	DO III=1,NUMSTR
!	IF (STRMAP(III,2*FUN).GT.STRMA) THEN
!	WRITE(*,*) 'ERROR: MAXIMUM FOUND'
!	PAUSE
!	END IF
!	END DO
!	END IF

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(*,*)	PNLR(1),PNFR(1),PNBB(1),NEND(1)
 	WRITE(*,*)	LRL(1),FRL(1),BBL(1),BETA(1)
	WRITE(*,*)	SZMA,STRMA,NDEQ,EQL,EQB
	WRITE(*,*)
	WRITE(20,*)	PNLR(1),PNFR(1),PNBB(1),NEND(1)
 	WRITE(20,*)	LRL(1),FRL(1),BBL(1),BETA(1)
	WRITE(20,*)	SZMA,STRMA,NDEQ,EQL,EQB
	WRITE(20,*)
	END IF

	IF ((TTA.EQ.0).AND.(FLAGAZ.EQ.1)) THEN
	CALL LDSTB(0)
	END IF	
	IF ((TTA.GT.0).AND.(MOD(I,INV/10).EQ.0)) THEN
	CALL LDSTB(1)
	NUMAV=NUMAV+1
	LSGAV=LSGAV+LSEG+LSEGF
	NSTRAV=NSTRAV+NUMSTR
	NEND(2)=NEND(2)+NEND(1)
	NLNR(2)=NLNR(2)+NLNR(1)
	NBR(2)=NBR(2)+NBR(1)
	NBRP3(2)=NBRP3(2)+NBRP3(1)
	NBRP4(2)=NBRP4(2)+NBRP4(1)
	BETA(2)=BETA(2)+BETA(1)
	PNLR(2)=PNLR(2)+PNLR(1)
	PNFR(2)=PNFR(2)+PNFR(1)
	PNBB(2)=PNBB(2)+PNBB(1)
	LRL(2)=LRL(2)+LRL(1)
	FRL(2)=FRL(2)+FRL(1)
	BBL(2)=BBL(2)+BBL(1)
	END IF

	IF (TTA.GT.TTAMA) THEN
	GOTO 34
	END IF

	END DO A01

34	WRITE(24,*) 'ENSEMBLE EQUILIBRATION FINISH'
	WRITE(*,*) 'ENSEMBLE EQUILIBRATION FINISH'

	IF (OUTMB.EQ.0)	THEN
	WRITE(32,*)	'SEGMENTAL LENGTH: ',Ls*Lp
	DO I=1,NUMDTR(1)
	WRITE(32,*)	MDTR1(I,1),MDTR1(I,2)/(NUMAV+0.0),MDTR2(I,1:2)/(NUMAV+0.0)
	END DO
	WRITE(33,*)	'SEGMENTAL LENGTH: ',Ls*Lp
	DO I=1,NUMDTR(2)
	WRITE(33,*)	SDTR1(I,1),SDTR1(I,2)/(NUMAV+0.0),SDTR2(I,1:3)/(NUMAV+0.0)
	END DO
	WRITE(36,*)	'SEGMENTAL LENGTH: ',Ls*Lp
	DO I=1,MAX(FUMDTR(1),FUMDTR(2))
	WRITE(36,*)	FDTR1(I,1),FDTR2(I,1)/(NUMAV+0.0),FDTR1(I,2),FDTR2(I,2)&
	&/(NUMAV+0.0),FDTR1(I,3),FDTR2(I,3)/(NUMAV+0.0)
	END DO
	END IF

	CLOSE(32)
	CLOSE(33)
	CLOSE(36)

	IF (OUTMB.EQ.0)	THEN
 	WRITE(34,*) 'PARAMETERS PART'
 	WRITE(34,*) 'TIME STEP:',DT
 	WRITE(34,*) 'SEGMENTAL LENGTH:',Ls*Lp
 	WRITE(34,*) 'PLATEAU:',G0
 	WRITE(34,*) 'RATIO:',RATIO	
 	WRITE(34,*) 'BUD:',RATIO_BD
	WRITE(34,*)	'REPTATION TIME:',trep
	WRITE(34,*) 'BREAKAGE RATE:',Kbr
    WRITE(34,*) 'MICELLE LENGTH:',LBAR*TL*Lp
	WRITE(34,*)	'STRAND LENGTH:',LSGAV/NSTRAV
 	WRITE(34,*) 'ALPHA:',APH
    WRITE(34,*) 'PERSISTENCE:',Lp
	WRITE(34,*) 'SEGMENTAL RATIO:',Ls
 	WRITE(34,*) 'NUMBER OF SEGMENTS:',LSGAV/NUMAV
 	WRITE(34,*) 'NUMBER OF STRANDS:',NSTRAV/NUMAV
 	WRITE(34,*) 'NUMBER OF FREE ENDS:',NEND(2)/NUMAV
	WRITE(34,*) 'NUMBER OF LINEAR MICELLE:',NLNR(2)/NUMAV
 	WRITE(34,*) 'NUMBER OF BRANCH MICELLE:',NBR(2)/NUMAV
	WRITE(34,*) 'NUMBER OF Y BRANCH POINT:',NBRP3(2)/NUMAV
	WRITE(34,*) 'NUMBER OF + BRANCH POINT:',NBRP4(2)/NUMAV
    WRITE(34,*) 'NUMBER OF BRANCH PER MICRON:',BETA(2)/NUMAV 
    WRITE(34,*) 'PERCENTAGE OF LINEAR MICELLE:',PNLR(2)/NUMAV 
    WRITE(34,*) 'PERCENTAGE OF FREE ARM:',PNFR(2)/NUMAV  
    WRITE(34,*) 'PERCENTAGE OF BACKBONE:',PNBB(2)/NUMAV 
    WRITE(34,*) 'LENGTH OF LINEAR MICELLE:',LRL(2)/NUMAV 
    WRITE(34,*) 'LENGTH OF FREE ARM:',FRL(2)/NUMAV  
    WRITE(34,*) 'LENGTH OF BACKBONE:',BBL(2)/NUMAV
	END IF
		 
	CLOSE(34) 
	CLOSE(27)
	CLOSE(28) 
	CLOSE(29)
	CLOSE(30)

!==================================================================
!		    BRANCHED ENSEMBLE INITIATION PART
!==================================================================

A04:IF (OUTMB.EQ.0) THEN
 	OPEN(38,FILE='GENERAL_INFO.DAT')
 	WRITE(38,*)	NLF,NUMSTR
	WRITE(38,*)	LSEG,LSEGF
	WRITE(38,*)	NUMDTR(2)
	CLOSE(38)

	OPEN(38,FILE='LMAP_INFO.DAT')
	DO I=1,NUM+NLF
	WRITE(38,*) LMAP(I,1:LLMAP)
	END DO
	CLOSE(38)

	OPEN(38,FILE='FMAP_INFO.DAT')
	DO I=1,NUM+NLF
	WRITE(38,*)	FMAP(I,1:LFMAP)
	END DO
	CLOSE(38)

	OPEN(38,FILE='STRMAP_INFO.DAT')
	DO I=1,NUMSTR
	WRITE(38,*)	STRMAP(I,1:LSTRMAP)
	END DO
	CLOSE(38)

	OPEN(38,FILE='STRINF_INFO.DAT')
	DO I=1,NUMSTR
	WRITE(38,*)	STRINF(I,1:LINF)
	END DO
	CLOSE(38)

	OPEN(38,FILE='STRDST_INFO.DAT')
	DO I=1,NUMDTR(2)
	WRITE(38,*)	SDTR1(I,1:2)
	END DO
	CLOSE(38)

    ELSE

 	OPEN(38,FILE='GENERAL_INFO.DAT')
 	READ(38,*)	NLF,NUMSTR
	READ(38,*)	LSEG,LSEGF
	READ(38,*)	NUMDTR(2)
	CLOSE(38)

	OPEN(38,FILE='LMAP_INFO.DAT')
	DO I=1,NUM+NLF
	READ(38,*,END=35) LMAP(I,1:LLMAP)
	END DO
35	CLOSE(38)

	OPEN(38,FILE='FMAP_INFO.DAT')
	DO I=1,NUM+NLF
	READ(38,*,END=36) FMAP(I,1:LFMAP)
	END DO
36	CLOSE(38)

	OPEN(38,FILE='STRMAP_INFO.DAT')
	DO I=1,NUMSTR
	READ(38,*,END=37) STRMAP(I,1:LSTRMAP)
	END DO
37	CLOSE(38)

	OPEN(38,FILE='STRINF_INFO.DAT')
	DO I=1,NUMSTR
	READ(38,*,END=38)	STRINF(I,1:LINF)
	END DO
38	CLOSE(38)

	OPEN (38,FILE='STRDST_INFO.DAT')
	DO I=1,NUMDTR(2)
	READ(38,*,END=39)	SDTR1(I,1:2)
	SDTR1(I,2)=SDTR1(I,2)/100
	END DO
39	CLOSE(38)
	END IF 	A04

!==================================================================
!		    BRANCHED ENSEMBLE INITIATION PART
!==================================================================

	DO I=1,NUMSTR
	DO K=1,STRMAP(K,2*FUN+1)
	STRPNT(I,K)=0.
	END DO
	STRMAP(I,2*FUN+1)=2
	STRPNT(I,1)=0.
	STRPNT(I,2)=STRMAP(I,2*FUN)+STRINF(I,1)
	END DO

	NUMAV=0		  ! *
	LSEGAV=0.	  ! *
	CALL LDSTB(0) ! *

	WRITE(24,*) 'BRANCHED CHAIN LIST INITIATION FINISH'
	WRITE(*,*) 'BRANCHED CHAIN LIST INITIATION FINISH'

!==================================================================
!			BRANCHED MICELLE RELAXATION PART  
!==================================================================

	NT=1
	FLAGEQ=1
	MARK=tbr/DT/NUM/2.
	G2=1.   ! *
	Nt0=TT  ! *
	
	OPEN(19,FILE='TEMP.DAT')

A02:DO I=1,TT

	IF (I.EQ.1) THEN
	J1=0
	J2=0
	END IF

!   BUDDING START

B02:DO WHILE (I.GT.J1*BUD)
	J1=J1+1

41	CALL RANDOM_NUMBER(RND)
	LBUD=INT(RND*(LSEG+LSEGF))
	IF (LBUD.LT.1) THEN
	GOTO 41
	END IF

	DO K=1,NUM+NLF
	IF (LBUD.EQ.0) THEN
	LPI(1)=K
	EXIT
	END IF
	LBUD=LBUD-LMAP(K,2)						
	IF (LBUD.LT.0) THEN	
	LBUD=LBUD+LMAP(K,2)
	LPI(1)=K
	EXIT
	END IF
	END DO 

	CALL EXTR_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	SIZ1=LMAP(LPI(1),6)	

	CALL UPDT_LST(FLAGEQ,LPI(1))
	STAT=0
	CALL BUDDING(FLAGEQ,LBUD,SIZ1,SMMAP1,SMINF1,SMPNT1,SIZ2,SMMAP2,SMINF2,SMPNT2,STAT)

	IF (STAT.LT.0) THEN
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	GOTO 41
	ELSE
    CALL RODR_STR(FLAGEQ,SIZ2,SMMAP2,SMINF2,SMPNT2,SMMAP1,SMINF1,SMPNT1)
	SIZ1=SIZ2
    CALL RFMAP(SIZ1,SMMAP1,SMINF1,LMMAP,FMMAP1,SMINF2)
	DO II=1,6
	LMAP(LPI(1),II)=LMMAP(II)
	END DO
	FMAP(LPI(1),2)=FMMAP1(2)
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF2,SMPNT1)

!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'BUDDING PROBLEM'
!	CALL PTER(FLAGEQ,2,SIZ1,SMMAP1,SMINF2,SMPNT1)
!	PAUSE
!	END IF

	END IF

	END DO B02

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP BUDDING FINISH, NUMSTR:',NUMSTR
	WRITE(*,*) I,' STEP BUDDING FINISH, NUMSTR:',NUMSTR 
	END IF

!   MICELLE BREAKAGE & REJOINING START

	SUM1=0
	NEND(1)=0.
	DO K=1,NUM+NLF
	SUM1=SUM1+LMAP(K,2)
	NEND(1)=NEND(1)+LMAP(K,5)
	END DO
	LSEGF=SUM1-LSEG

B12:IF (I.GT.J2*MARK) THEN

	J2=J2+1
	CALL RANDOM_NUMBER(BR)
	IF (NLF.LT.(-1)*PNLF*NUM) THEN
	BR=0.25
	END IF
	IF (NLF.GT.PNLF*NUM) THEN
	BR=0.75
	END IF

	CALL BKINF(KK,XCH,FLAGBK) ! *
	IF (FLAGBK.LT.0) THEN	  ! *
	BR=0.25					  ! *
	END IF					  ! *

C12:IF (BR.LT.0.5) THEN

42  CALL BKINF(LPI(1),LBR,FLAGBK)	! *
    IF (FLAGBK.GT.0) THEN ! *

    CALL RANDOM_NUMBER(RND)
	LBR=INT(RND*(LSEG+LSEGF))

	DO K=1,NUM+NLF
	IF (LBR.EQ.0) THEN
	LPI(1)=K
	EXIT
	END IF
	LBR=LBR-LMAP(K,2)					
	IF (LBR.LT.0) THEN		
	LBR=LBR+LMAP(K,2)
	LPI(1)=K
	EXIT
	END IF
	END DO

	END IF	 ! *

	CALL EXTR_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	CALL UPDT_LST(FLAGEQ,LPI(1))
	SIZ1=LMAP(LPI(1),6)

	STAT=0
	CALL BRKG(FLAGEQ,LBR,SIZ1,SMMAP1,SMINF1,SMPNT1,SIZ2,SMMAP2,SMINF2,SMPNT2,&
	&SIZ3,SMMAP3,SMINF3,SMPNT3,STAT)

	IF (STAT.LT.0) THEN
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	GOTO 42
	ELSE
	CALL RNFM_STR(FLAGEQ,SIZ2,SMMAP2,SMINF2,SMPNT2,SIZ1,SMMAP1,SMINF1,SMPNT1)
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP2,SMINF2,SMPNT2)	
	SIZ2=SIZ1
    CALL RFMAP(SIZ2,SMMAP2,SMINF2,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(LPI(1),II)=LMMAP(II)
	END DO
	FMAP(LPI(1),2)=FMMAP1(2)
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP2,SMINF1,SMPNT2)

!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'BREAKAGE PROBLEM 1'
!	CALL PTER(FLAGEQ,1,SIZ2,SMMAP2,SMINF1,SMPNT2)
!	PAUSE
!	END IF
!   CALL TRNSF(FLAGEQ,2,SIZ2,SMMAP2,SMINF1,SMPNT2)

	CALL RNFM_STR(FLAGEQ,SIZ3,SMMAP3,SMINF3,SMPNT3,SIZ1,SMMAP1,SMINF1,SMPNT1)
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP3,SMINF3,SMPNT3)
	SIZ3=SIZ1
    CALL RFMAP(SIZ3,SMMAP3,SMINF3,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(NUM+NLF+1,II)=LMMAP(II)
	END DO
 	FMAP(NUM+NLF+1,2)=FMMAP1(2)
 	FMAP(NUM+NLF+1,1)=FMAP(LPI(1),1)  ! *
	CALL INST_STR(FLAGEQ,NUM+NLF+1,SMMAP3,SMINF1,SMPNT3)

	NLF=NLF+1

!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'BREAKAGE PROBLEM 2'
!	CALL PTER(FLAGEQ,2,SIZ3,SMMAP3,SMINF1,SMPNT3)
!	PAUSE
!	END IF

	END IF

	ELSE

43  CALL RANDOM_NUMBER(RND)
	LREC1=INT(RND*NEND(1))
    CALL RANDOM_NUMBER(RND)
	LREC2=INT(RND*NEND(1))

	IF ((LREC1.LT.1).OR.(LREC2.LT.1)) THEN
	GOTO 43
	END IF
	IF (LREC1.EQ.LREC2) THEN
	GOTO 43
	END IF

    DO K=1,NUM+NLF
	LREC1=LREC1-LMAP(K,5)
	IF (LREC1.LE.0) THEN
	LREC1=LREC1+LMAP(K,5)
	LPI(1)=K
	EXIT
	END IF
	END DO 
    DO K=1,NUM+NLF
	LREC2=LREC2-LMAP(K,5)
	IF (LREC2.LE.0) THEN
	LREC2=LREC2+LMAP(K,5)
	LPI(2)=K
	EXIT
	END IF
	END DO 

	IF (LPI(1).EQ.LPI(2)) THEN
	GOTO 43
	END IF

	SUM1=LMAP(LPI(1),6)+LMAP(LPI(2),6)
	IF (SUM1.GT.SZMA)	THEN
	GOTO 43
	END IF

	CALL EXTR_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	SIZ1=LMAP(LPI(1),6)

	CALL UPDT_LST(FLAGEQ,LPI(1))
	CALL EXTR_STR(FLAGEQ,LPI(2),SMMAP2,SMINF2,SMPNT2)
	SIZ2=LMAP(LPI(2),6)

	CALL UPDT_LST(FLAGEQ,LPI(2))

	STAT=0
	CALL REJN(FLAGEQ,LREC1,SIZ1,SMMAP1,SMINF1,SMPNT1,LREC2,SIZ2,SMMAP2,SMINF2,&
	&SMPNT2,SIZ3,SMMAP3,SMINF3,SMPNT3,STAT)

	IF (STAT.LT.0) THEN
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP1,SMINF1,SMPNT1)
	CALL INST_STR(FLAGEQ,LPI(2),SMMAP2,SMINF2,SMPNT2)
	GOTO 43
	ELSE
	CALL RNFM_STR(FLAGEQ,SIZ3,SMMAP3,SMINF3,SMPNT3,SIZ1,SMMAP1,SMINF1,SMPNT1)
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP3,SMINF3,SMPNT3)
	SIZ3=SIZ1
    CALL RFMAP(SIZ3,SMMAP3,SMINF3,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(LPI(1),II)=LMMAP(II)
	END DO
	FMAP(LPI(1),2)=FMMAP1(2)
	FMAP(LPI(1),1)=0.5*(FMAP(LPI(1),1)+FMAP(LPI(2),1)) ! *
	CALL INST_STR(FLAGEQ,LPI(1),SMMAP3,SMINF1,SMPNT3)

	CALL RFLM(LPI(2))
	NLF=NLF-1

!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'REJOIN PROBLEM'
!	CALL PTER(FLAGEQ,2,SIZ1,SMMAP3,SMINF1,SMPNT3)
!	PAUSE
!	END IF

	END IF

	END IF C12

	END IF B12

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP BRKG&REJN FINISH, NLF:',NLF
	WRITE(*,*) I,' STEP BRKG&REJN FINISH, NLF:',NLF 
	END IF

!   FLUIDITY OF MICELLE BRANCH POINT START

B22:DO K=1,NUM+NLF
	IF (LMAP(K,1).NE.0)	THEN

	CALL EXTR_STR(FLAGEQ,K,SMMAP1,SMINF1,SMPNT1)
	CALL UPDT_LST(FLAGEQ,K)							  
	SIZ1=LMAP(K,6)
	FMMAP1(1)=FMAP(K,1)

	FLAG=1
	DO WHILE (FLAG.EQ.1)
    CALL DISP(FLAGEQ,FMMAP1,SIZ1,SMMAP1,SMINF1,SMPNT1,FMMAP2,SIZ2,SMMAP2,SMINF2,SMPNT2)
	CALL RNFM_STR(FLAGEQ,SIZ2,SMMAP2,SMINF2,SMPNT2,SIZ1,SMMAP1,SMINF1,SMPNT1)
	IF (FMMAP2(1).LT.1.) THEN
	FLAG=0
	ELSE
	FMMAP1(1)=FMMAP2(1)-1.
	END IF
	END DO

	FMAP(K,1)=FMMAP2(1) 
    CALL RODR_STR(FLAGEQ,SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP2,SMINF2,SMPNT2) 
	SIZ2=SIZ1
    CALL RFMAP(SIZ2,SMMAP2,SMINF2,LMMAP,FMMAP1,SMINF1)
	DO II=1,6
	LMAP(K,II)=LMMAP(II)
	END DO
	FMAP(K,2)=FMMAP1(2)
	CALL INST_STR(FLAGEQ,K,SMMAP2,SMINF1,SMPNT2)

!	IF (STAT.LT.0) THEN
!	WRITE(*,*) 'FLUIDITY PROBLEM'
!	CALL PTER(FLAGEQ,4,SIZ2,SMMAP2,SMINF1,SMPNT2)
!	PAUSE
!	END IF

	ELSE

	FMAP(K,1)=0.

	END IF
	END DO B22

	SUM1=0
	DO K=1,NUM+NLF
	SUM1=SUM1+LMAP(K,2)
	END DO
	LSEGF=SUM1-LSEG

	IF (MOD(I,INV).EQ.0) THEN
	WRITE(20,*) I,' STEP FLUIDITY FINISH, LSEGF:',LSEGF 
	WRITE(*,*) I,' STEP FLUIDITY FINISH, LSEGF:',LSEGF
	END IF

!   RELAXATION OF STRAND START

    DO K=1,NUM+NLF
	CALL EXTR_STR(FLAGEQ,K,SMMAP1,SMINF1,SMPNT1)
	CALL UPDT_LST(FLAGEQ,K)
	SIZ1=LMAP(K,6)
    CALL MPDR(SIZ1,SMMAP1,SMINF1,SMPNT1,SMMAP2,SMPNT2)
	CALL INST_STR(FLAGEQ,K,SMMAP2,SMINF1,SMPNT2)
	END DO 						

	G21=G2						   ! CALCULATE STRESS RELAXATION FUNCTION
	G2=0.
	DO K=1,NUMSTR
	II=1
	DO WHILE (II.LE.STRMAP(K,2*FUN+1))
	G2=G2+(STRPNT(K,II+1)-STRPNT(K,II))/(LSEG+LSEGF)
	II=II+2
	END DO
	END DO
	IF (LDR.EQ.1) THEN
	G2=G2**2
	END IF
	G22=G2

	IF ((G21.GE.0.9).AND.(G22.LE.0.9)) THEN	 ! *
	Nt0=I	  ! *
	NUMG=1	  ! *
	END IF	  ! *

	IF (I.GE.Nt0) THEN
	CALL GGT(I,G21,G22)				! PICK APPROPRIATE NUMBER OF THE DATA FROM TEMPORARY FILE
	END IF

 	IF (MOD(I,INV).EQ.0) THEN
	WRITE(*,*)	I,' STEP RELAXATION FINISH:',G2
	WRITE(20,*)	I,' STEP RELAXATION FINISH:',G2
	WRITE(*,*)
	CALL LDSTB(1)	! *
	LSEGAV=LSEGAV+LSEG+LSEGF
	NUMAV=NUMAV+1	! *
	END IF

  	IF (G2.LT.0.001) THEN
	REM=I
	WRITE(19,*)	-1,I*DT,G2
	WRITE(*,*) 'REM: ',I
	WRITE(20,*)	'REM: ',I
	EXIT
	END IF

	END DO A02

	NUMG=NUMG-2
	WRITE(24,*) 'SIMULATION FINISH'
	WRITE(*,*) 'SIMULATION FINISH'

	CLOSE(19)   

    WRITE(*,*) 'INITIATION OF GA FINISHED'
	WRITE(24,*) 'INITIATION OF GA FINISHED'

!==================================================================
!			TIME TO FREQUENCY TRANSFORMATION
!==================================================================

	tMAX=LOG(T(NUMG))
	tMIN=LOG(T(1))
 	ERRG=10.
	DO I=1,5
	CALL GEAM(FLAGG,TRY_NN,TRY_MIU,TRY_TAO,TRY_ERRG)
	IF (TRY_ERRG.LT.ERRG) THEN
	NN=TRY_NN
	DO J=1,NN
	TAGET_MIU(J)=TRY_MIU(J)
	TAGET_TAO(J)=TRY_TAO(J)
	END DO
	ERRG=TRY_ERRG
	END IF
	WRITE(*,*)	'TRY',I,' ERR:',TRY_ERRG
	WRITE(23,*)	'TRY',I,' ERR:',TRY_ERRG
	IF (ERRG.LT.1E-2) THEN
	EXIT
	END IF
	END DO

 	WRITE(23,*)	'RELAXATION SPECTURM'
	DO I=1,NN
	WRITE(23,*) EXP(TAGET_MIU(I)),TAGET_TAO(I)
	WRITE(*,*) EXP(TAGET_MIU(I)),TAGET_TAO(I)
	END DO
    WRITE(*,*) 'GENETIC ALGORITHM: ',ERRG
	WRITE(20,*) 'GENETIC ALGORITHM: ',ERRG

	WRITE(24,*)	'GA ERROR: ',ERRG
    WRITE(24,*) 'RELAXATION TIME CALCULATION FINISH'
	WRITE(*,*) 'RELAXATION TIME CALCULATION FINISH'

	IF (OUTGT.EQ.1) THEN 
 	WRITE(17,*) 'PARAMETERS PART'
 	WRITE(17,*) 'PLATEAU:',G0
 	WRITE(17,*) 'RATIO:',RATIO	
 	WRITE(17,*) 'BUD:',RATIO_BD	
    WRITE(17,*) 'MICELLE LENGTH:',LBAR*TL
 	WRITE(17,*) 'ALPHA:',APH
    WRITE(17,*) 'PERSISTENCE:',Lp 
    WRITE(17,*) 'DIAMETER:',d  
 	WRITE(17,*) 'DATA PART'
    DO I=1,NUMG
	WRITE(17,*) T(I),G(I),GF(I)
    END DO
	CLOSE(17)
	END IF

	DO I=1,NUMOU		  ! GENERATE SIMULATED G'&G" FOR LOW FREQUENCY
	W=10**(FMI+DW*I)
	GG(I)=0.
	GGG(I)=0.
	DO K=1,NN
	GG(I)=GG(I)+G0*EXP(TAGET_MIU(K))*(W*TAGET_TAO(K))**2./(1.+(W*TAGET_TAO(K))**2.)
	GGG(I)=GGG(I)+G0*EXP(TAGET_MIU(K))*(W*TAGET_TAO(K))/(1.+(W*TAGET_TAO(K))**2.)
	END DO
	END DO

 	IF (OUTW.EQ.1) THEN 
 	WRITE(18,*) 'PARAMETERS PART'
 	WRITE(18,*) 'PLATEAU:',G0
 	WRITE(18,*) 'RATIO:',RATIO	
 	WRITE(18,*) 'BUD:',RATIO_BD	
    WRITE(18,*) 'MICELLE LENGTH:',LBAR*TL
 	WRITE(18,*) 'ALPHA:',APH
    WRITE(18,*) 'PERSISTENCE:',Lp 
    WRITE(18,*) 'DIAMETER:',d     
 	WRITE(18,*) 'DATA PART'
    DO I=1,NUMOU
	WRITE(18,*) 10**(FMI+DW*I),GG(I),GGG(I)
    END DO
	CLOSE(18)
	END IF

!==================================================================
!				    HIGH FREQUENCY SIMULATION
!==================================================================

A03:IF (LROUSE.EQ.1) THEN  ! ROUSE MODES
    DO I=1,NUMOU
	W=10**(FMI+DW*I)
	GGS=0.
    GGGS=0.

	DO K=1,NUMDTR(2)
	Z=CEILING(SDTR1(K,1)/APH)
	NM=CEILING(SDTR1(K,1)/2.)
	IF (Z.GE.1) THEN
	VOF=SDTR1(K,2)*SDTR1(K,1)/LSEGAV ! **
	ELSE
	CYCLE 
	END IF
	GGC=0.
	GGGC=0.
	DO II=Z,NM
	GGC=GGC+1./(4.*(II/Z)**4+(W*te)**2)
	GGGC=GGGC+2.*(II/Z)**2/(4.*(K/Z)**4+(W*te)**2)
	END DO
	GGC=GGC*5./4.*(W*te)**2*VOF/Z
	GGGC=GGGC*5./4.*W*te*VOF/Z
	GGS=GGS+GGC*G0
	GGGS=GGGS+GGGC*G0
	END DO

	GG(I)=GG(I)+GGS
	GGG(I)=GGG(I)+GGGS
	END DO
	WRITE(24,*) 'ROUSE MODE INCLUDED'
	WRITE(*,*) 'ROUSE MODE INCLUDED'
	END IF A03

 	IF (OUTR.EQ.1) THEN 
 	WRITE(21,*) 'PARAMETERS PART'
 	WRITE(21,*) 'PLATEAU:',G0
 	WRITE(21,*) 'RATIO:',RATIO	
 	WRITE(21,*) 'BUD:',RATIO_BD	
    WRITE(21,*) 'MICELLE LENGTH:',LBAR*TL
 	WRITE(21,*) 'ALPHA:',APH
    WRITE(21,*) 'PERSISTENCE:',Lp 
    WRITE(21,*) 'DIAMETER:',d     
 	WRITE(21,*) 'DATA PART'
    DO I=1,NUMOU
	WRITE(21,*) 10**(FMI+DW*I),GG(I),GGG(I)
    END DO
	CLOSE(21)
	END IF

 	IF (LBEND.EQ.1) THEN	! BENDING MODES
	DO I=1,NUMOU
	W=10**(FMI+DW*I)
	DO J=1,NUMDTR(2)
	CLENTH=SDTR1(J,1)*Ls*TL
	WB=W*(CLENTH/APH)**2.*te
	WB=WB**2./(1.+WB**2.)
	VOF=SDTR1(J,2)*SDTR1(J,1)/LSEGAV  ! *     
	GG(I)=GG(I)+VOF*(ST*W**0.75)*WB
	GGG(I)=GGG(I)+VOF*(OS*W**0.75+W*Vs)*WB
	END DO
	END DO
	WRITE(24,*) 'BENDING MODE INCLUDED'
	WRITE(*,*) 'BENDING MODE INCLUDED'
	END IF

 	WRITE(35,*) 'PARAMETERS PART'
 	WRITE(35,*) 'PLATEAU:',G0
 	WRITE(35,*) 'RATIO:',RATIO	
 	WRITE(35,*) 'BUD:',RATIO_BD
	WRITE(35,*)	'REPTATION:',trep
    WRITE(35,*) 'MICELLE LENGTH:',LBAR*TL*Lp
 	WRITE(35,*) 'ALPHA:',APH
    WRITE(35,*) 'PERSISTENCE:',Lp 
    WRITE(35,*) 'DIAMETER:',d     
 	WRITE(35,*) 'DATA PART'
    DO I=1,NUMOU
	WRITE(35,*) 10**(FMI+DW*I),GG(I),GGG(I)
    END DO
	CLOSE(35)

	CLOSE(20)	
	CLOSE(24)

	STOP

	END PROGRAM MAIN

!==================================================================
!				         END HERE
!==================================================================























!==================================================================
!      SUBROUTINE 1: EXTRACT STRAND INFORMATION FROM STRAND LIST
!==================================================================

	SUBROUTINE EXTR_STR(FLAGPi1,NUMi1,STRMAPo1,STRINFo1,STRPNTo1)

	USE SHARED

	REAL, INTENT(OUT) :: STRPNTo1(505,1010),STRINFo1(505,5)
	INTEGER :: Is1,Js1,LOCs1,SIZs1,CENs1,LENTHs1
	INTEGER, INTENT(IN) :: NUMi1,FLAGPi1
	INTEGER, INTENT(OUT) ::	STRMAPo1(505,20)

	LOCs1=LMAP(NUMi1,7)
	SIZs1=LMAP(NUMi1,6)

	DO Is1=1,SIZs1
	CENs1=Is1-1+LOCs1
	DO Js1=1,LSTRMAP
	STRMAPo1(Is1,Js1)=STRMAP(CENs1,Js1)
	END DO
	DO Js1=1,LINF
	STRINFo1(Is1,Js1)=STRINF(CENs1,Js1)
	END DO

	IF (FLAGPi1.EQ.1) THEN
	LENTHs1=STRMAPo1(Is1,2*FUN+1)
	DO Js1=1,LENTHs1
	STRPNTo1(Is1,Js1)=STRPNT(CENs1,Js1)
	END DO
	END IF
	END DO

	RETURN

	END SUBROUTINE EXTR_STR

!==================================================================
!      SUBROUTINE 2: UPDATE LISTS OF STRAND AND MICELLE
!==================================================================

	SUBROUTINE UPDT_LST(FLAGPi2,NUMi2)
 
	USE SHARED

	INTEGER :: Is2,Js2,LOCs2,SIZs2,LENTHs2
	INTEGER, INTENT(IN) :: NUMi2,FLAGPi2

	SIZs2=LMAP(NUMi2,6)
	LOCs2=LMAP(NUMi2,7)

    DO Is2=LOCs2,NUMSTR-SIZs2
	DO Js2=1,LSTRMAP
 	STRMAP(Is2,Js2)=STRMAP(Is2+SIZs2,Js2)
	END DO
	DO Js2=1,LINF
 	STRINF(Is2,Js2)=STRINF(Is2+SIZs2,Js2)
	END DO

	IF (FLAGPi2.EQ.1) THEN
	LENTHs2=STRMAP(Is2,2*FUN+1)
 	DO Js2=1,LENTHs2
	STRPNT(Is2,Js2)=STRPNT(Is2+SIZs2,Js2)
	END DO
	END IF
	END DO
	NUMSTR=NUMSTR-SIZs2

	DO Is2=1,NUM+NLF
	IF (LMAP(Is2,7).GT.LOCs2) THEN
	LMAP(Is2,7)=LMAP(Is2,7)-SIZs2
	END IF
	END DO

	RETURN

	END	SUBROUTINE UPDT_LST

!==================================================================
!      SUBROUTINE 3: INSERT STRAND INFORMATION BACK TO STRAND LIST
!==================================================================

	SUBROUTINE INST_STR(FLAGPi3,NUMi3,STRMAPi3,STRINFi3,STRPNTi3)

	USE SHARED

	REAL, INTENT(IN) :: STRPNTi3(505,1010),STRINFi3(505,5)
	INTEGER :: Is3,Js3,SIZs3,LENTHs3
	INTEGER, INTENT(IN) :: NUMi3,STRMAPi3(505,20),FLAGPi3

	SIZs3=LMAP(NUMi3,6)
	LMAP(NUMi3,7)=NUMSTR+1
	DO Is3=1,SIZs3
	DO Js3=1,LSTRMAP
 	STRMAP(NUMSTR+Is3,Js3)=STRMAPi3(Is3,Js3)
	END DO
	DO Js3=1,LINF
 	STRINF(NUMSTR+Is3,Js3)=STRINFi3(Is3,Js3)
	END DO

	IF (FLAGPi3.EQ.1) THEN
	LENTHs3=STRMAP(NUMSTR+Is3,2*FUN+1)
 	DO Js3=1,LENTHs3
	STRPNT(NUMSTR+Is3,Js3)=STRPNTi3(Is3,Js3)
	END DO
	END IF
	END DO
	NUMSTR=NUMSTR+SIZs3

	RETURN

	END SUBROUTINE INST_STR

!==================================================================
!      SUBROUTINE 4: REORDER STRAND LIST OF CERTAIN MICELLE
!==================================================================
	
	SUBROUTINE RODR_STR(FLAGPi4,SIZi4,STRMAPi4,STRINFi4,STRPNTi4,&
	&STRMAPo4,STRINFo4,STRPNTo4)

	USE SHARED

	REAL, INTENT(IN) :: STRPNTi4(505,1010),STRINFi4(505,5)
	REAL, INTENT(OUT) :: STRPNTo4(505,1010),STRINFo4(505,5)
	REAL :: XCHPs4(1010),XCHRs4(1010),XCHFs4(5)
	INTEGER :: Is4,Js4,MAX1s4,LENTH1s4,LENTH2s4,FLAGs4,XCHMs4(7),IIs4
	INTEGER :: Ks4,LOCs4,CENs4,MAX2s4(14),FLAGTs4,XCHOs4(14),FLAGRs4
	INTEGER :: ORND(500,14),NUMs4
	INTEGER, INTENT(IN) :: SIZi4,STRMAPi4(505,20),FLAGPi4
	INTEGER, INTENT(OUT) :: STRMAPo4(505,20)


	DO Is4=1,SIZi4
	DO Js4=1,LSTRMAP
	STRMAPo4(Is4,Js4)=STRMAPi4(Is4,Js4)
	END DO
	DO Js4=1,LINF
	STRINFo4(Is4,Js4)=STRINFi4(Is4,Js4)
	END DO

	IF (FLAGPi4.EQ.1) THEN
	LENTH1s4=STRMAPo4(Is4,2*FUN+1)+1
	DO Js4=1,LENTH1s4
	STRPNTo4(Is4,Js4)=STRPNTi4(Is4,Js4)
	END DO
	END IF
	END DO

	FLAGRs4=0
	DO Is4=1,SIZi4
	IF (STRMAPo4(Is4,2*FUN-1).GT.SIZi4) THEN
	FLAGRs4=1
	END IF
	END DO

S01:IF (FLAGRs4.EQ.1) THEN
    DO Is4=1,SIZi4
	NUMs4=SIZi4+1-Is4
	IF (STRMAPo4(Is4,2*FUN-1).NE.NUMs4) THEN
    LOCs4=STRMAPo4(Is4,2*FUN-1)
	STRMAPo4(Is4,2*FUN-1)=NUMs4

	DO Js4=Is4+1,SIZi4
	IF (STRMAPo4(Js4,2*FUN-1).EQ.NUMs4) THEN
	STRMAPo4(Js4,2*FUN-1)=LOCs4
	EXIT
	END IF
	END DO

	DO Ks4=1,SIZi4
	DO IIs4=1,2*(FUN-1)
	IF (STRMAPo4(Ks4,IIs4).EQ.LOCs4) THEN
	STRMAPo4(Ks4,IIs4)=-1
	END IF
	END DO
	END DO

	DO Ks4=1,SIZi4
	DO IIs4=1,2*(FUN-1)
	IF (STRMAPo4(Ks4,IIs4).EQ.NUMs4) THEN
	STRMAPo4(Ks4,IIs4)=LOCs4
	END IF
	END DO
	END DO

	DO Ks4=1,SIZi4
	DO IIs4=1,2*(FUN-1)
	IF (STRMAPo4(Ks4,IIs4).EQ.-1) THEN
	STRMAPo4(Ks4,IIs4)=NUMs4
	END IF
	END DO
	END DO

	END IF
	END DO	
	END IF	S01

    DO Is4=1,SIZi4
	ORND(Is4,1)=STRMAPo4(Is4,2*FUN-1)
	DO Js4=1,2*FUN-2	
	ORND(Is4,Js4+1)=STRMAPo4(Is4,Js4)
	END DO
	ORND(Is4,2*FUN)=STRMAPo4(Is4,2*FUN-1)
	END DO

	FLAGTs4=1
S02:DO WHILE (FLAGTs4.EQ.1)
	FLAGTs4=0

S03:DO Is4=1,SIZi4
	DO Js4=1,2
	CENs4=FUN*(Js4-1)
	DO Ks4=1,FUN-1
	MAX1s4=ORND(Is4,CENs4+Ks4)
	DO IIs4=Ks4+1,FUN 
	IF (MAX1s4.LT.ORND(Is4,CENs4+IIs4)) THEN
	MAX1s4=ORND(Is4,CENs4+IIs4)
	LOCs4=ORND(Is4,CENs4+Ks4)
	ORND(Is4,CENs4+Ks4)=ORND(Is4,CENs4+IIs4)
	ORND(Is4,CENs4+IIs4)=LOCs4
	END IF
	END DO
	END DO
	END DO

	IIs4=1
  	DO Ks4=1,2*FUN
	IF (ORND(Is4,Ks4).NE.STRMAPo4(Is4,2*FUN-1)) THEN
	STRMAPo4(Is4,IIs4)=ORND(Is4,Ks4)
	IIs4=IIs4+1
	END IF
	END DO
	END DO	S03

S04:DO Is4=1,SIZi4	
 	FLAGs4=0
	DO Js4=1,FUN			   
	IF (ORND(Is4,Js4).LT.ORND(Is4,FUN+Js4)) THEN
	FLAGs4=1
	EXIT
	END IF
	IF (ORND(Is4,Js4).GT.ORND(Is4,FUN+Js4)) THEN
	FLAGs4=0
	EXIT
	END IF
	END DO

	IF (FLAGs4.EQ.1) THEN
	CENs4=FUN-1
	DO Js4=1,FUN-1
	LOCs4=STRMAPo4(Is4,Js4)
	STRMAPo4(Is4,Js4)=STRMAPo4(Is4,Js4+CENs4)
	STRMAPo4(Is4,Js4+CENs4)=LOCs4
	END DO
	DO Js4=1,FUN
	LOCs4=ORND(Is4,Js4)
	ORND(Is4,Js4)=ORND(Is4,Js4+FUN)
	ORND(Is4,Js4+FUN)=LOCs4
	END DO

	IF (FLAGPi4.EQ.1) THEN
	LENTH1s4=STRMAPo4(Is4,2*FUN+1)
	DO Js4=1,LENTH1s4
	XCHRs4(Js4)=STRMAPo4(Is4,2*FUN)+STRINFo4(Is4,1)-STRPNTo4(Is4,Js4)
	END DO
	DO Js4=1,LENTH1s4
	STRPNTo4(Is4,LENTH1s4+1-Js4)=XCHRs4(Js4)
	END DO
	END IF
	END IF
	END DO S04

S05:DO Is4=1,SIZi4-1
	DO Js4=1,2*FUN
	MAX2s4(Js4)=ORND(Is4,Js4)
	END DO
    DO Js4=Is4+1,SIZi4
		
	FLAGs4=0
	DO Ks4=1,2*FUN
	IF (ORND(Js4,Ks4).GT.MAX2s4(Ks4)) THEN
	FLAGs4=1
	EXIT
	ELSE
	IF (ORND(Js4,Ks4).LT.MAX2s4(Ks4))	THEN
	FLAGs4=0
	EXIT
	END IF
	END IF
	END DO

	IF (FLAGs4.EQ.1) THEN
	FLAGTs4=1
	DO Ks4=1,2*FUN
	MAX2s4(Ks4)=ORND(Js4,Ks4)
	END DO
	LENTH1s4=STRMAPo4(Is4,2*FUN+1)
	LENTH2s4=STRMAPo4(Js4,2*FUN+1)
	DO Ks4=1,LSTRMAP
	XCHMs4(Ks4)=STRMAPo4(Is4,Ks4)
	STRMAPo4(Is4,Ks4)=STRMAPo4(Js4,Ks4)
	STRMAPo4(Js4,Ks4)=XCHMs4(Ks4)
	END DO 
	DO Ks4=1,LINF
	XCHFs4(Ks4)=STRINFo4(Is4,Ks4)
	STRINFo4(Is4,Ks4)=STRINFo4(Js4,Ks4)
	STRINFo4(Js4,Ks4)=XCHFs4(Ks4)
	END DO
	DO Ks4=1,2*FUN
	XCHOs4(Ks4)=ORND(Is4,Ks4)
	ORND(Is4,Ks4)=ORND(Js4,Ks4)
	ORND(Js4,Ks4)=XCHOs4(Ks4)
	END DO 
	IF (FLAGPi4.EQ.1) THEN
	DO Ks4=1,LENTH1s4
	XCHPs4(Ks4)=STRPNTo4(Is4,Ks4)
	END DO
	DO Ks4=1,LENTH2s4
	STRPNTo4(Is4,Ks4)=STRPNTo4(Js4,Ks4)
	END DO
	DO Ks4=1,LENTH1s4
	STRPNTo4(Js4,Ks4)=XCHPs4(Ks4)
	END DO
	END IF
	END IF

	END DO
	END DO S05

S06:IF (FLAGTs4.EQ.1) THEN
	DO Is4=1,SIZi4
	NUMs4=SIZi4+1-Is4
	IF (STRMAPo4(Is4,2*FUN-1).NE.NUMs4) THEN
    LOCs4=STRMAPo4(Is4,2*FUN-1)
	STRMAPo4(Is4,2*FUN-1)=NUMs4

	DO Js4=Is4+1,SIZi4
	IF (STRMAPo4(Js4,2*FUN-1).EQ.NUMs4) THEN
	STRMAPo4(Js4,2*FUN-1)=LOCs4
	EXIT
	END IF
	END DO

	DO Ks4=1,SIZi4
	DO IIs4=1,2*(FUN-1)
	IF (STRMAPo4(Ks4,IIs4).EQ.LOCs4) THEN
	STRMAPo4(Ks4,IIs4)=-1
	END IF
	END DO
	DO IIs4=1,2*FUN
	IF (ORND(Ks4,IIs4).EQ.LOCs4) THEN
	ORND(Ks4,IIs4)=-1
	END IF
	END DO
	END DO

	DO Ks4=1,SIZi4
	DO IIs4=1,2*(FUN-1)
	IF (STRMAPo4(Ks4,IIs4).EQ.NUMs4) THEN
	STRMAPo4(Ks4,IIs4)=LOCs4
	END IF
	END DO
	DO IIs4=1,2*FUN
	IF (ORND(Ks4,IIs4).EQ.NUMs4) THEN
	ORND(Ks4,IIs4)=LOCs4
	END IF
	END DO
	END DO

	DO Ks4=1,SIZi4
	DO IIs4=1,2*(FUN-1)
	IF (STRMAPo4(Ks4,IIs4).EQ.-1) THEN
	STRMAPo4(Ks4,IIs4)=NUMs4
	END IF
	END DO
	DO IIs4=1,2*FUN
	IF (ORND(Ks4,IIs4).EQ.-1) THEN
	ORND(Ks4,IIs4)=NUMs4
	END IF
	END DO
	END DO

	END IF
	END DO
	END IF S06

	END DO S02

	RETURN

	END SUBROUTINE RODR_STR

!==================================================================
!      SUBROUTINE 5: BUDDING
!==================================================================

	SUBROUTINE BUDDING(FLAGPi5,NUMi5,SIZi5,STRMAPi5,STRINFi5,STRPNTi5&
	&,SIZo5,STRMAPo5,STRINFo5,STRPNTo5,STATo5)

	USE SHARED

	REAL, INTENT(IN) :: STRPNTi5(505,1010),STRINFi5(505,5)
	REAL, INTENT(OUT) :: STRPNTo5(505,1010),STRINFo5(505,5)
	INTEGER :: Is5,Js5,LOCs5,CENs5,LENTHs5,NUMP1s5,NUMP2s5,SUMs5
	INTEGER :: FLAGBB,NUMSs5(7),Ks5,IIs5,JJs5,KKs5,MULs5,NMZs5
	INTEGER, INTENT(IN) :: NUMi5,SIZi5,STRMAPi5(505,20),FLAGPi5
	INTEGER, INTENT(OUT) :: SIZo5,STATo5,STRMAPo5(505,20)

	STATo5=1
	LOCs5=NUMi5
	FLAGBB=0

	DO Is5=1,SIZi5
	DO Js5=1,LSTRMAP
	STRMAPo5(Is5,Js5)=STRMAPi5(Is5,Js5)
	END DO
	DO Js5=1,LINF
	STRINFo5(Is5,Js5)=STRINFi5(Is5,Js5)
	END DO
	
	IF (FLAGPi5.EQ.1) THEN
	LENTHs5=STRMAPi5(Is5,2*FUN+1)
	DO Js5=1,LENTHs5
	STRPNTo5(Is5,Js5)=STRPNTi5(Is5,Js5)
	END DO
	END IF
	END DO

S07:DO Is5=1,SIZi5
	SUMs5=0
	MULs5=1
	NMZs5=0

	IF (LOCs5.EQ.0) THEN
	DO Js5=1,FUN-1
	SUMs5=SUMs5+STRMAPi5(Is5,Js5)
	MULs5=MULs5*STRMAPi5(Is5,Js5)
	IF (STRMAPi5(Is5,Js5).EQ.0) THEN
	NMZs5=NMZs5+1
	END IF
	END DO
	IF ((SUMs5.EQ.0).OR.(MULs5.NE.0)) THEN
	STATo5=-1
	RETURN
	ELSE
	FLAGBB=1
	CENs5=Is5
	NMZs5=MIN(NMZs5,FUN-2)
	EXIT
	END IF
	END IF

	LOCs5=LOCs5-STRMAPi5(Is5,2*FUN)
	IF (LOCs5.LT.0) THEN
	LOCs5=LOCs5+STRMAPi5(Is5,2*FUN)
	CENs5=Is5
	EXIT
	END IF
	END DO S07

	IF (FLAGPi5.EQ.1) THEN
	LENTHs5=STRMAPi5(CENs5,2*FUN+1)
	NUMP1s5=0
	NUMP2s5=0
	DO Is5=1,LENTHs5
	IF (STRPNTi5(CENs5,Is5).LE.LOCs5) THEN
	NUMP1s5=NUMP1s5+1
	END IF
	END DO
	NUMP2s5=STRMAPi5(CENs5,2*FUN+1)-NUMP1s5
	END IF

!	OPEN(38,FILE='TEST1.DAT')

S08:IF (FLAGBB.EQ.0) THEN
	NUMSs5=0

	DO Is5=FUN,2*(FUN-1)
	STRMAPo5(CENs5,Is5)=0
	END DO
	STRMAPo5(CENs5,FUN)=SIZi5+1
	DO Is5=1,FUN-2
	STRMAPo5(CENs5,FUN+Is5)=SIZi5+1+Is5
	END DO
 	STRMAPo5(CENs5,2*FUN)=LOCs5
	STRINFo5(CENs5,1)=0.

	DO Is5=1,FUN-1
	STRMAPo5(SIZi5+1,Is5)=0
	END DO
	STRMAPo5(SIZi5+1,1)=STRMAPi5(CENs5,2*FUN-1)
	DO Is5=1,FUN-2
	STRMAPo5(SIZi5+1,1+Is5)=SIZi5+1+Is5
	END DO

!	WRITE(38,*)	
!	WRITE(38,*)	'NUMBER 1: '
!	WRITE(38,*)	STRMAPo5(SIZi5+1,2*FUN-1),': ',STRMAPo5(SIZi5+1,2*FUN),STRINFo5(SIZi5+1,1)
!	WRITE(38,*)	STRMAPo5(SIZi5+1,1:2*FUN-2)

	Js5=1
	DO Is5=FUN,2*(FUN-1)
	STRMAPo5(SIZi5+1,Is5)=STRMAPi5(CENs5,Is5)
	IF (STRMAPi5(CENs5,Is5).NE.0) THEN
	NUMSs5(Js5)=STRMAPi5(CENs5,Is5)
	Js5=Js5+1
	END IF
	END DO
	STRMAPo5(SIZi5+1,2*FUN-1)=SIZi5+1
	STRMAPo5(SIZi5+1,2*FUN)=STRMAPi5(CENs5,2*FUN)-LOCs5
	STRINFo5(SIZi5+1,1)=STRINFi5(CENs5,1)

	DO Ks5=1,FUN-2
	DO Is5=1,2*(FUN-1)
	STRMAPo5(SIZi5+1+Ks5,Is5)=0
	END DO
	STRMAPo5(SIZi5+1+Ks5,1)=STRMAPi5(CENs5,2*FUN-1)
	STRMAPo5(SIZi5+1+Ks5,2)=SIZi5+1
	IIs5=3
	DO Is5=1,FUN-2
	IF (Is5.NE.Ks5) THEN
	STRMAPo5(SIZi5+1+Ks5,IIs5)=SIZi5+1+Is5
	IIs5=IIs5+1
	END IF
	END DO
	STRMAPo5(SIZi5+1+Ks5,2*FUN-1)=SIZi5+1+Ks5
	STRMAPo5(SIZi5+1+Ks5,2*FUN)=1
	STRINFo5(SIZi5+1+Ks5,1)=-1.
	END DO 

!	WRITE(38,*)	
!	WRITE(38,*)	'NUMBER 2: '
!	WRITE(38,*)	STRMAPo5(SIZi5+1,2*FUN-1),': ',STRMAPo5(SIZi5+1,2*FUN),STRINFo5(SIZi5+1,1)
!	WRITE(38,*)	STRMAPo5(SIZi5+1,1:2*FUN-2)

S09:IF (FLAGPi5.EQ.1) THEN
	IF (MOD(NUMP1s5,2).NE.0) THEN
	STRMAPo5(CENs5,2*FUN+1)=NUMP1s5+1
	STRPNTo5(CENs5,NUMP1s5+1)=LOCs5
	ELSE
	STRMAPo5(CENs5,2*FUN+1)=NUMP1s5
	END IF

 	IF (MOD(NUMP2s5,2).NE.0) THEN
	STRMAPo5(SIZi5+1,2*FUN+1)=NUMP2s5+1
 	STRPNTo5(SIZi5+1,1)=0.
	DO Is5=1,NUMP2s5
	STRPNTo5(SIZi5+1,1+Is5)=STRPNTi5(CENs5,NUMP1s5+Is5)-LOCs5
	END DO
	ELSE
	STRMAPo5(SIZi5+1,2*FUN+1)=NUMP2s5
	DO Is5=1,NUMP2s5
	STRPNTo5(SIZi5+1,Is5)=STRPNTi5(CENs5,NUMP1s5+Is5)-LOCs5
	END DO
	END IF

	DO Is5=1,FUN-2
	STRMAPo5(SIZi5+1+Is5,2*FUN+1)=0
	END DO
	END IF S09

!	WRITE(38,*)	
!	WRITE(38,*)	'NUMBER 3: '
!	WRITE(38,*)	STRMAPo5(SIZi5+1,2*FUN-1),': ',STRMAPo5(SIZi5+1,2*FUN),STRINFo5(SIZi5+1,1)
!	WRITE(38,*)	STRMAPo5(SIZi5+1,1:2*FUN-2)

    DO Is5=1,Js5-1
	DO Ks5=1,SIZi5
	IF (STRMAPi5(Ks5,2*FUN-1).EQ.NUMSs5(Is5)) THEN
	IIs5=Ks5
	EXIT	
	END IF
	END DO

    DO Ks5=1,2*(FUN-1)
	IF (STRMAPi5(IIs5,Ks5).EQ.STRMAPi5(CENs5,2*FUN-1)) THEN
	STRMAPo5(IIs5,Ks5)=SIZi5+1
	EXIT
	END IF
	END DO	
	END DO

!	WRITE(38,*)	
!	WRITE(38,*)	'NUMBER 4: '
!	WRITE(38,*)	STRMAPo5(SIZi5+1,2*FUN-1),': ',STRMAPo5(SIZi5+1,2*FUN),STRINFo5(SIZi5+1,1)
!	WRITE(38,*)	STRMAPo5(SIZi5+1,1:2*FUN-2)

	SIZo5=SIZi5+FUN-1
	END IF S08

!	CLOSE(38)

S10:IF (FLAGBB.EQ.1) THEN
	NUMSs5=0
 	STRMAPo5(CENs5,2*FUN)=STRMAPi5(CENs5,2*FUN)
	
	Ks5=1	
	DO Is5=1,FUN-1
	IF (STRMAPi5(CENs5,Is5).EQ.0) THEN
	STRMAPo5(CENs5,Is5)=SIZi5+Ks5
	Ks5=Ks5+1
	END IF
	IF (Ks5.GT.NMZs5) THEN
	EXIT
	END IF
	END DO

 	Js5=1
	DO Is5=1,FUN-1
	IF (STRMAPi5(CENs5,Is5).NE.0) THEN
 	NUMSs5(Js5)=STRMAPi5(CENs5,Is5)
	Js5=Js5+1
	END IF
	END DO

	IF (FLAGPi5.EQ.1) THEN
	STRMAPo5(CENs5,2*FUN+1)=STRMAPi5(CENs5,2*FUN+1)
	LENTHs5=STRMAPo5(CENs5,2*FUN+1)
	DO Is5=1,LENTHs5
	STRPNTo5(CENs5,Is5)=STRPNTi5(CENs5,Is5)
	END DO
	END IF

	DO Ks5=1,NMZs5
	DO Is5=FUN,2*(FUN-1)
	STRMAPo5(SIZi5+Ks5,Is5)=0
	END DO
	STRMAPo5(SIZi5+Ks5,1)=STRMAPi5(CENs5,2*FUN-1)
	DO Is5=1,Js5-1
	STRMAPo5(SIZi5+Ks5,Is5+1)=NUMSs5(Is5)
	END DO
	IIs5=Js5+1
	DO Is5=1,NMZs5
	IF (Is5.NE.Ks5) THEN
	STRMAPo5(SIZi5+Ks5,IIs5)=SIZi5+Is5
	IIs5=IIs5+1
	END IF
	END DO
	STRMAPo5(SIZi5+Ks5,2*FUN-1)=SIZi5+Ks5
    STRMAPo5(SIZi5+Ks5,2*FUN)=1
 	STRMAPo5(SIZi5+Ks5,2*FUN+1)=0
	STRINFo5(SIZi5+Ks5,1)=-1.
	END DO
	
S11:DO Is5=1,Js5-1
	DO Ks5=1,SIZi5
	IF (STRMAPi5(Ks5,2*FUN-1).EQ.NUMSs5(Is5)) THEN
	IIs5=Ks5
	EXIT	
	END IF
	END DO

    DO Ks5=1,2*(FUN-1)
	IF (STRMAPi5(IIs5,Ks5).EQ.STRMAPi5(CENs5,2*FUN-1)) THEN
	KKs5=1
	IF (Ks5.LE.FUN-1) THEN
	DO JJs5=1,FUN-1
	IF (STRMAPi5(IIs5,JJs5).EQ.0) THEN 
	STRMAPo5(IIs5,JJs5)=SIZi5+KKs5
	KKs5=KKs5+1
	IF (KKs5.GT.NMZs5) THEN
	GOTO 01
	END IF
	END IF
	END DO
	ELSE
 	DO JJs5=FUN,2*(FUN-1)
	IF (STRMAPi5(IIs5,JJs5).EQ.0) THEN
	STRMAPo5(IIs5,JJs5)=SIZi5+KKs5
	KKs5=KKs5+1
	IF (KKs5.GT.NMZs5) THEN
	GOTO 01
	END IF
	END IF
	END DO
	END IF
	END IF
	END DO

01	STATo5=1	
	END DO	S11

	SIZo5=SIZi5+NMZs5
	END IF S10

	RETURN

	END SUBROUTINE BUDDING

!==================================================================
!      SUBROUTINE 6: CALCULATE END DISPLACEMENT 
!==================================================================

 	SUBROUTINE DISP(FLAGPi6,FMAPi6,SIZi6,STRMAPi6,STRINFi6,STRPNTi6&
	&,FMAPo6,SIZo6,STRMAPo6,STRINFo6,STRPNTo6)

	USE SHARED

 	REAL :: A(1000,1000),B(1000),X(1000),Z(1000),L(1000,1000),XR,TSUMs6
	REAL :: U(1000,1000),RNDs6,MLs6,TMINs6,FTIM(505) 
	REAL, INTENT(IN) :: STRPNTi6(505,1010),STRINFi6(505,5),FMAPi6(5)
	REAL, INTENT(OUT) :: STRPNTo6(505,1010),STRINFo6(505,5),FMAPo6(5)
	INTEGER :: Is6,Js6,Ks6,IIs6,JJs6,CENs6,LOCs6,LENTHs6,NOD(500,7),SUMs6
	INTEGER :: MAXs6,FLAGs6,Fs6(2,14),FNs6(3),FNSs6(3),SIGND(500,7),NUMPs6 
	INTEGER :: FLAGFTs6,FSTR(505),MGN(505),EMAP(500)
	INTEGER, INTENT(IN) :: SIZi6,STRMAPi6(505,20),FLAGPi6
	INTEGER, INTENT(OUT) :: SIZo6,STRMAPo6(505,20)

	FLAGFTs6=0
	SIZo6=SIZi6
	DO Is6=1,3*SIZo6
	DO Js6=1,3*SIZo6
	A(Is6,Js6)=0.
	L(Is6,Js6)=0.
	U(Is6,Js6)=0.
	END DO
	B(Is6)=0.
	Z(Is6)=0.
	X(Is6)=0.
	END DO
 

    IIs6=1
S13:DO Is6=1,SIZo6
	DO Js6=1,2
	NOD(IIs6,1)=STRMAPi6(Is6,2*FUN-1)
	CENs6=(Js6-1)*(FUN-1)

	DO Ks6=1,FUN-1
	NOD(IIs6,Ks6+1)=STRMAPi6(Is6,Ks6+CENs6)
	END DO

	DO Ks6=1,FUN-1
	MAXs6=NOD(IIs6,Ks6)
	DO JJs6=Ks6+1,FUN
	IF (MAXs6.LT.NOD(IIs6,JJs6)) THEN
	MAXs6=NOD(IIs6,JJs6)
	LOCs6=NOD(IIs6,Ks6)
	NOD(IIs6,Ks6)=NOD(IIs6,JJs6)
	NOD(IIs6,JJs6)=LOCs6
	END IF
	END DO
	END DO

	DO Ks6=1,IIs6-1
	FLAGs6=0
	DO JJs6=1,FUN
	IF (NOD(IIs6,JJs6).EQ.NOD(Ks6,JJs6)) THEN
	FLAGs6=FLAGs6+1
	END IF
	END DO
	IF (FLAGs6.EQ.FUN) THEN
	GOTO 02
	END IF
	END DO

	IIs6=IIs6+1
02	FLAGs6=0
	DO JJs6=1,FUN-1	 ! *
	IF (STRMAPi6(Is6,JJs6+CENs6).NE.0) THEN	 ! *
	FLAGs6=1	 ! *
	EXIT	 ! *
	END IF	 ! *
	END DO	 ! *
	IF (FLAGs6.EQ.0) THEN   ! *
	EMAP(Is6)=1	! *
	ELSE	 ! *
	EMAP(Is6)=0	! *
	END IF	 ! *

	END DO 
	END DO S13

	SUMs6=IIs6-1


S14:DO Is6=1,SUMs6-1
    MAXs6=Is6
    DO Js6=Is6+1,SUMs6
	FLAGs6=0

	DO Ks6=1,FUN
	IF (NOD(MAXs6,Ks6).LT.NOD(Js6,Ks6)) THEN
	FLAGs6=1
	EXIT
	END IF
	IF (NOD(MAXs6,Ks6).GT.NOD(Js6,Ks6)) THEN
	FLAGs6=0
	EXIT
	END IF	
	END DO

	IF (FLAGs6.EQ.1) THEN
	MAXs6=Js6
	DO Ks6=1,FUN
	LOCs6=NOD(Is6,Ks6)
	NOD(Is6,Ks6)=NOD(Js6,Ks6)
	NOD(Js6,Ks6)=LOCs6
	END DO
	END IF
	END DO
	END DO S14


S15:DO Is6=1,SIZo6

	CALL RANDOM_NUMBER(RNDs6)
	RNDs6=RNDs6*2.-1.
	MLs6=STRMAPi6(Is6,2*FUN)+STRINFi6(Is6,1)
	IF ((STRMAPi6(Is6,2*FUN).EQ.1).AND.(STRINFi6(Is6,1).EQ.-1.)) THEN
	MLs6=Ld
	END IF
	B(Is6)=RNDs6*C3*SQRT((1.+FMAPi6(1))/MLs6)

	A(Is6,Is6)=1.
	DO Js6=1,2
	Fs6(Js6,1)=STRMAPi6(Is6,2*FUN-1)
	CENs6=(Js6-1)*(FUN-1)
	DO Ks6=1,FUN-1
	Fs6(Js6,Ks6+1)=STRMAPi6(Is6,CENs6+Ks6)
	END DO
	END DO

	DO Js6=1,2
	DO Ks6=1,FUN-1
	MAXs6=Fs6(Js6,Ks6)
	DO IIs6=Ks6+1,FUN
	IF (MAXs6.LT.Fs6(Js6,IIs6)) THEN
	MAXs6=Fs6(Js6,IIs6)
	LOCs6=Fs6(Js6,Ks6)
	Fs6(Js6,Ks6)=Fs6(Js6,IIs6)
	Fs6(Js6,IIs6)=LOCs6
	END IF
	END DO
	END DO
	END DO

S16:DO Js6=1,2
	DO Ks6=1,SUMs6
 
   	FLAGs6=1
    DO IIs6=1,FUN
	IF (NOD(Ks6,IIs6).NE.Fs6(Js6,IIs6)) THEN
	FLAGs6=0
	EXIT
	END IF
	END DO

	IF (FLAGs6.EQ.1) THEN
	FNs6(Js6)=Ks6
	DO IIs6=1,FUN
	IF (NOD(Ks6,IIs6).EQ.STRMAPi6(Is6,2*FUN-1)) THEN
	FNSs6(Js6)=IIs6
	END IF
	END DO
	EXIT
	END IF
	END DO
	END DO S16

	A(Is6,FNs6(1)+SIZo6)=(-1.)*C4*(1.+FMAPi6(1))/MLs6	
	SIGND(FNs6(1),FNSs6(1))=-1

	A(Is6,FNs6(2)+SIZo6)=C4*(1.+FMAPi6(1))/MLs6
	SIGND(FNs6(2),FNSs6(2))=1

	END DO S15
		
	DO Is6=1,SUMs6
	B(Is6+SIZo6)=0.
	FLAGs6=0
	
	DO Js6=1,FUN
	IF (NOD(Is6,Js6).NE.0) THEN
	FLAGs6=FLAGs6+1
	END IF
	END DO
	
	IF (FLAGs6.LT.2) THEN
	A(Is6+SIZo6,Is6+SIZo6)=1	
	ELSE
	DO Js6=1,FUN
	IF (NOD(Is6,Js6).NE.0) THEN
	DO Ks6=1,SIZo6
	IF (STRMAPi6(Ks6,2*FUN-1).EQ.NOD(Is6,Js6)) THEN
	LOCs6=Ks6
	EXIT	
	END IF
	END DO	
	A(Is6+SIZo6,LOCs6)=SIGND(Is6,Js6)
	END IF
	END DO
	END IF
	END DO 

S17:DO Js6=1,SIZo6+SUMs6
	DO Is6=Js6,SIZo6+SUMs6

	TSUMs6=0.
	DO Ks6=1,Js6-1
	TSUMs6=TSUMs6+L(Is6,Ks6)*U(Ks6,Js6)
	END DO
	L(Is6,Js6)=A(Is6,Js6)-TSUMs6

	IF (Is6.EQ.Js6) THEN
	U(Js6,Js6)=1.
	ELSE
	TSUMs6=0.
	DO Ks6=1,Js6-1
	TSUMs6=TSUMs6+L(Js6,Ks6)*U(Ks6,Is6)
	END DO
	U(Js6,Is6)=(A(Js6,Is6)-TSUMs6)/L(Js6,Js6)
	END IF

	END DO
	END DO S17


	DO Is6=1,SUMs6+SIZo6
	TSUMs6=0.
	DO Ks6=1,Is6-1
	TSUMs6=TSUMs6+L(Is6,Ks6)*Z(Ks6)
	END DO
	Z(Is6)=(B(Is6)-TSUMs6)/L(Is6,Is6)
	END DO

!	WRITE(37,*)	'Z: '
!	WRITE(37,*)	Z(1:SUMs6+SIZo6)

    DO Js6=1,SIZo6+SUMs6
	Is6=SIZo6+SUMs6+1-Js6
	TSUMs6=0.
	DO Ks6=Is6+1,SIZo6+SUMs6
	TSUMs6=TSUMs6+U(Is6,Ks6)*X(Ks6)
	END DO
	X(Is6)=Z(Is6)-TSUMs6
	END DO    

!	WRITE(37,*)
!	WRITE(37,*)	'X: '
!	WRITE(37,*)	X(1:SUMs6+SIZo6)
!	CLOSE(37)

S18:DO Is6=1,SIZo6
	DO Js6=1,LSTRMAP
	STRMAPo6(Is6,Js6)=STRMAPi6(Is6,Js6)
	END DO

	DO Js6=1,2
 	CENs6=(Js6-1)*(FUN-1)
	FLAGs6=0
 	DO Ks6=1,FUN-1
	IF (STRMAPi6(Is6,CENs6+Ks6).NE.0) THEN
	FLAGs6=FLAGs6+1 
	END IF
	END DO
	IF (FLAGs6.EQ.0) THEN
	STRINFo6(Is6,1)=STRINFi6(Is6,1)+X(Is6)
	EXIT
	ELSE
	STRINFo6(Is6,1)=STRINFi6(Is6,1)
	END IF
	END DO

	IF (FLAGPi6.EQ.1) THEN
	LENTHs6=STRMAPi6(Is6,2*FUN+1)
	DO Js6=1,LENTHs6
	STRPNTo6(Is6,Js6)=STRPNTi6(Is6,Js6)
	END DO
	END IF
	END DO S18
	JJs6=1
    DO Is6=1,SIZo6
	FLAGs6=0
	TSUMs6=STRINFo6(Is6,1)+STRMAPi6(Is6,2*FUN)
	DO Js6=1,2
 	CENs6=(Js6-1)*(FUN-1)
 	DO Ks6=1,FUN-1
	IF (STRMAPi6(Is6,CENs6+Ks6).NE.0) THEN
	FLAGs6=FLAGs6+1
	EXIT 
	END IF
	END DO
	END DO

	IF ((FLAGs6.LT.2).AND.(TSUMs6.LE.0.)) THEN
	FLAGFTs6=1
	FSTR(JJs6)=STRMAPi6(Is6,2*FUN-1)
	JJs6=JJs6+1
	END IF
	END DO 

	JJs6=JJs6-1
S19:IF (FLAGFTs6.EQ.1) THEN

	DO Is6=1,JJs6
	DO Js6=1,SIZo6
	IF (STRMAPi6(Js6,2*FUN-1).EQ.FSTR(Is6)) THEN
	LOCs6=Js6
	EXIT
	END IF
	END DO
	XR=STRINFi6(LOCs6,1)+STRMAPi6(LOCs6,2*FUN)
	IF (X(LOCs6).NE.0.) THEN
	FTIM(Is6)=XR/ABS(X(LOCs6))
	ELSE
	FTIM(Is6)=0.
	END IF
	END DO

   	TMINs6=FTIM(1)
	IIs6=FSTR(1)
	DO Is6=1,JJs6
	IF (TMINs6.GT.FTIM(Is6)) THEN
	TMINs6=FTIM(Is6)
 	IIs6=FSTR(Is6)
	END IF
	END DO

!	WRITE(37,*)
!	WRITE(37,*)	'DISAPPEARED STRAND:'
!	WRITE(37,*)	TMINs6,IIs6

	FMAPo6(1)=(1.-TMINs6)*(1.+FMAPi6(1))
 	DO Js6=1,SIZo6
	IF (STRMAPi6(Js6,2*FUN-1).EQ.IIs6) THEN
	LOCs6=Js6
	EXIT
	END IF
	END DO

!	WRITE(37,*)
!	WRITE(37,*)	'REMAINED TIME:'
!	WRITE(37,*)	FMAPo6(1),LOCs6
!	CLOSE(37)

	IF ((STRMAPi6(LOCs6,2*FUN).NE.1).AND.(STRINFi6(LOCs6,1).NE.-1.)) THEN
	XR=ABS(X(LOCs6))/(STRINFi6(LOCs6,1)+STRMAPi6(LOCs6,2*FUN))
    DO Is6=1,SIZo6+SUMs6
	X(Is6)=X(Is6)/XR
	END DO
	ELSE
    DO Is6=1,SIZo6+SUMs6
	X(Is6)=0.
	END DO
	END IF

        IIs6=1
	DO Is6=1,JJs6
	IF (FTIM(Is6).EQ.TMINs6) THEN
	MGN(IIs6)=FSTR(Is6)
	IIs6=IIs6+1
	END IF
	END DO

!	WRITE(37,*)
!	WRITE(37,*)	'SAME DISAPPEAR STRANDS'
!	WRITE(37,*)	IIs6-1,':'
!	WRITE(37,*) MGN(1:IIs6-1)
!	CLOSE(37)

	ELSE
	FMAPo6(1)=0.

	END IF	S19

	IIs6=IIs6-1
S20:IF (FLAGFTs6.EQ.1) THEN

    DO Is6=1,SIZo6
	DO Js6=1,2
 	CENs6=(Js6-1)*(FUN-1)
	FLAGs6=0
 	DO Ks6=1,FUN-1
	IF (STRMAPi6(Is6,CENs6+Ks6).NE.0) THEN
	FLAGs6=FLAGs6+1 
	END IF
	END DO
	IF (FLAGs6.EQ.0) THEN
	STRINFo6(Is6,1)=STRINFi6(Is6,1)+X(Is6)
	EXIT
	END IF
	END DO
	END DO 

	DO Is6=1,IIs6
	DO Js6=1,SIZo6
	DO Ks6=1,2*(FUN-1)
	IF (STRMAPo6(Js6,Ks6).EQ.MGN(Is6)) THEN
	STRMAPo6(Js6,Ks6)=0
	END IF
	END DO
	END DO

 	DO Js6=1,SIZo6
	IF (STRMAPo6(Js6,2*FUN-1).EQ.MGN(Is6)) THEN
	LOCs6=Js6
	EXIT
	END IF
	END DO

 	DO Js6=LOCs6,SIZo6-1
	DO Ks6=1,LSTRMAP
	STRMAPo6(Js6,Ks6)=STRMAPo6(Js6+1,Ks6)
	END DO
	DO Ks6=1,LINF
	STRINFo6(Js6,Ks6)=STRINFo6(Js6+1,Ks6)
	END DO
	IF (FLAGPi6.EQ.1) THEN
	LENTHs6=STRMAPo6(Js6,2*FUN+1)
	DO Ks6=1,LENTHs6
	STRPNTo6(Js6,Ks6)=STRPNTo6(Js6+1,Ks6)
	END DO
	END IF
	END DO
	SIZo6=SIZo6-1
	END DO

	END IF S20

	IF (SIZo6.LT.3) THEN  ! *
	FMAPo6(1)=0.		  ! *
	END IF				  !	*

S21:IF (FLAGPi6.EQ.1) THEN
	DO Is6=1,SIZo6
	MLs6=STRMAPo6(Is6,2*FUN)+STRINFo6(Is6,1)
	LENTHs6=STRMAPo6(Is6,2*FUN+1)
	NUMPs6=0
	
	DO Js6=1,LENTHs6
	IF (STRPNTo6(Is6,Js6).GT.MLs6) THEN
	NUMPs6=NUMPs6+1
	END IF
	END DO

	IF (NUMPs6.GT.0) THEN
	IF (MOD(NUMPs6,2).NE.0) THEN
	STRMAPo6(Is6,2*FUN+1)=STRMAPo6(Is6,2*FUN+1)-NUMPs6+1
	STRPNTo6(Is6,LENTHs6-NUMPs6+1)=MLs6
	ELSE
	STRMAPo6(Is6,2*FUN+1)=STRMAPo6(Is6,2*FUN+1)-NUMPs6
	END IF
	END IF

	END DO
	END IF S21

	RETURN

	END SUBROUTINE DISP

!==================================================================
!      SUBROUTINE 7: STRAND STRUCTURE REINFORCEMENT
!==================================================================

 	SUBROUTINE RNFM_STR(FLAGPi7,SIZi7,STRMAPi7,STRINFi7,STRPNTi7,&
	&SIZo7,STRMAPo7,STRINFo7,STRPNTo7)

	USE SHARED

	REAL, INTENT(IN) :: STRPNTi7(505,1010),STRINFi7(505,5)
	REAL, INTENT(OUT) :: STRPNTo7(505,1010),STRINFo7(505,5)
	REAL :: ML1s7,ML2s7,XCHRs7(1010)
	INTEGER :: Is7,Js7,LOC1s7,CENs7,LENTH1s7,Ks7,LENTH2s7,DMLs7
	INTEGER :: FLAGs7,MSTRNs7(2,2),FLAGMs7,XCHs7,LOC2s7,FLAGLs7
	INTEGER, INTENT(IN) :: SIZi7,STRMAPi7(505,20),FLAGPi7
	INTEGER, INTENT(OUT) :: SIZo7, STRMAPo7(505,20)

	SIZo7=SIZi7
	DO Is7=1,SIZo7
	DO Js7=1,LSTRMAP
	STRMAPo7(Is7,Js7)=STRMAPi7(Is7,Js7)
	END DO
	DO Js7=1,LINF
	STRINFo7(Is7,Js7)=STRINFi7(Is7,Js7)
	END DO

	IF (FLAGPi7.EQ.1) THEN
	LENTH1s7=STRMAPo7(Is7,2*FUN+1)
	DO Js7=1,LENTH1s7
	STRPNTo7(Is7,Js7)=STRPNTi7(Is7,Js7)
	END DO
	END IF
	END DO

	FLAGLs7=1
S22:DO WHILE (FLAGLs7.EQ.1)
	FLAGLs7=0
    DO Is7=1,SIZo7
	FLAGMs7=0

	DO Js7=1,2
	CENs7=(Js7-1)*(FUN-1)
	FLAGs7=0
	DO Ks7=1,FUN-1
	IF (STRMAPo7(Is7,CENs7+Ks7).NE.0) THEN
	FLAGs7=FLAGs7+1
	MSTRNs7(2,1)=STRMAPo7(Is7,CENs7+Ks7)
	END IF
	END DO

	IF ((FLAGs7.LT.2).AND.(FLAGs7.NE.0)) THEN
	MSTRNs7(1,1)=Is7
	MSTRNs7(1,2)=Js7
	FLAGMs7=1
	FLAGLs7=1
	EXIT
	END IF
	END DO

	DO Js7=1,SIZo7
	IF (STRMAPo7(Js7,2*FUN-1).EQ.MSTRNs7(2,1)) THEN
	MSTRNs7(2,1)=Js7
	EXIT
	END IF
	END DO

S23:IF (FLAGMs7.EQ.1) THEN

	DO Js7=1,2
	CENs7=(Js7-1)*(FUN-1)
	LOC1s7=MSTRNs7(2,1)
	LOC2s7=MSTRNs7(1,1)	
	DO Ks7=1,FUN-1
	IF (STRMAPo7(LOC1s7,CENs7+Ks7).EQ.STRMAPo7(LOC2s7,2*FUN-1)) THEN
	MSTRNs7(2,2)=Js7
	GOTO 03
	END IF
	END DO
	END DO

03	IF (MSTRNs7(1,2)+MSTRNs7(2,2).NE.3) THEN
	LOC2s7=MSTRNs7(2,1)
	CENs7=FUN-1
	DO Js7=1,FUN-1
	XCHs7=STRMAPo7(LOC2s7,Js7)
	STRMAPo7(LOC2s7,Js7)=STRMAPo7(LOC2s7,Js7+CENs7)
	STRMAPo7(LOC2s7,Js7+CENs7)=XCHs7
	END DO
	IF (FLAGPi7.EQ.1) THEN
	LENTH2s7=STRMAPo7(LOC2s7,2*FUN+1)
	DO Js7=1,LENTH2s7
	XCHRs7(Js7)=STRMAPo7(LOC2s7,2*FUN)+STRINFo7(LOC2s7,1)-STRPNTo7(LOC2s7,Js7)
	END DO
	DO Js7=1,LENTH2s7
	STRPNTo7(LOC2s7,LENTH2s7+1-Js7)=XCHRs7(Js7)
	END DO
	END IF
	END IF

	LOC1s7=MSTRNs7(1,1)
	LOC2s7=MSTRNs7(2,1)
	LENTH1s7=STRMAPo7(LOC1s7,2*FUN+1)
	LENTH2s7=STRMAPo7(LOC2s7,2*FUN+1)
	ML1s7=STRMAPo7(LOC1s7,2*FUN)+STRINFo7(LOC1s7,1)
	ML2s7=STRMAPo7(LOC2s7,2*FUN)+STRINFo7(LOC2s7,1)
S24:IF (MSTRNs7(1,2).EQ.1) THEN
	STRINFo7(LOC2s7,1)=STRINFo7(LOC2s7,1)+STRINFo7(LOC1s7,1)
	IF (ABS(STRINFo7(LOC2s7,1)).GE.1.) THEN
	DMLs7=INT(STRINFo7(LOC2s7,1))
	ELSE
	DMLs7=0
	END IF

	IF (FLAGPi7.EQ.1) THEN
	DO Js7=1,LENTH1s7
	STRPNTo7(LOC2s7,Js7+LENTH2s7)=STRPNTo7(LOC1s7,Js7)+ML2s7
	END DO
	END IF

	STRINFo7(LOC2s7,1)=STRINFo7(LOC2s7,1)-DMLs7
	STRMAPo7(LOC2s7,2*FUN)=STRMAPo7(LOC2s7,2*FUN)+STRMAPo7(LOC1s7,2*FUN)+DMLs7
	STRMAPo7(LOC2s7,2*FUN+1)=STRMAPo7(LOC2s7,2*FUN+1)+STRMAPo7(LOC1s7,2*FUN+1)

	DO Js7=FUN,2*(FUN-1)
	STRMAPo7(LOC2s7,Js7)=STRMAPo7(LOC1s7,Js7)
	END DO

 	DO Js7=1,SIZo7
	IF (Js7.NE.LOC1s7) THEN
	DO Ks7=1,2*(FUN-1)
	IF (STRMAPo7(Js7,Ks7).EQ.STRMAPo7(LOC1s7,2*FUN-1)) THEN
	STRMAPo7(Js7,Ks7)=STRMAPo7(LOC2s7,2*FUN-1)
	END IF
	END DO
	END IF
	END DO

	DO Js7=LOC1s7,SIZo7
	DO Ks7=1,LSTRMAP
	STRMAPo7(Js7,Ks7)=STRMAPo7(Js7+1,Ks7)
	END DO
	DO Ks7=1,LINF
	STRINFo7(Js7,Ks7)=STRINFo7(Js7+1,Ks7)
	END DO
	IF (FLAGPi7.EQ.1) THEN
	LENTH1s7=STRMAPo7(Js7,2*FUN+1)
	DO Ks7=1,LENTH1s7
	STRPNTo7(Js7,Ks7)=STRPNTo7(Js7+1,Ks7)
	END DO
	END IF
	END DO

	SIZo7=SIZo7-1

	ELSE
 	STRINFo7(LOC1s7,1)=STRINFo7(LOC1s7,1)+STRINFo7(LOC2s7,1)
	IF (ABS(STRINFo7(LOC1s7,1)).GE.1.) THEN
	DMLs7=INT(STRINFo7(LOC1s7,1))
	ELSE
	DMLs7=0
	END IF

	IF (FLAGPi7.EQ.1) THEN
	DO Js7=1,LENTH2s7
	STRPNTo7(LOC1s7,Js7+LENTH1s7)=STRPNTo7(LOC2s7,Js7)+ML1s7
	END DO
	END IF

 	STRINFo7(LOC1s7,1)=STRINFo7(LOC1s7,1)-DMLs7
	STRMAPo7(LOC1s7,2*FUN)=STRMAPo7(LOC1s7,2*FUN)+STRMAPo7(LOC2s7,2*FUN)+DMLs7
	STRMAPo7(LOC1s7,2*FUN+1)=STRMAPo7(LOC1s7,2*FUN+1)+STRMAPo7(LOC2s7,2*FUN+1)

	DO Js7=FUN,2*(FUN-1)
	STRMAPo7(LOC1s7,Js7)=STRMAPo7(LOC2s7,Js7)
	END DO

 	DO Js7=1,SIZo7
	IF (Js7.NE.LOC2s7) THEN
	DO Ks7=1,2*(FUN-1)
	IF (STRMAPo7(Js7,Ks7).EQ.STRMAPo7(LOC2s7,2*FUN-1)) THEN
	STRMAPo7(Js7,Ks7)=STRMAPo7(LOC1s7,2*FUN-1)
	END IF
	END DO
	END IF
	END DO

	DO Js7=LOC2s7,SIZo7
	DO Ks7=1,LSTRMAP
	STRMAPo7(Js7,Ks7)=STRMAPo7(Js7+1,Ks7)
	END DO
	DO Ks7=1,LINF
	STRINFo7(Js7,Ks7)=STRINFo7(Js7+1,Ks7)
	END DO
	IF (FLAGPi7.EQ.1) THEN
	LENTH1s7=STRMAPo7(Js7,2*FUN+1)
	DO Ks7=1,LENTH1s7
	STRPNTo7(Js7,Ks7)=STRPNTo7(Js7+1,Ks7)
	END DO
	END IF
	END DO

	SIZo7=SIZo7-1

	END IF S24

	END IF S23

	END DO
	END DO S22

	DO Is7=1,SIZo7
	IF ((STRMAPo7(Is7,2*FUN).EQ.1).AND.(STRINFo7(Is7,1).EQ.-1.)) THEN
	CYCLE
	ELSE
 	IF (STRINFo7(Is7,1).GT.0.5) THEN
	STRMAPo7(Is7,2*FUN)=STRMAPo7(Is7,2*FUN)+1
	STRINFo7(Is7,1)=STRINFo7(Is7,1)-1.
	END IF
 	IF (STRINFo7(Is7,1).LT.-0.5) THEN
	STRMAPo7(Is7,2*FUN)=STRMAPo7(Is7,2*FUN)-1
	STRINFo7(Is7,1)=STRINFo7(Is7,1)+1.
	END IF
	END IF
	END DO

	RETURN

	END SUBROUTINE RNFM_STR

!==================================================================
!      SUBROUTINE 8: BREAKAGE
!==================================================================
	
	SUBROUTINE BRKG(FLAGPi8,NUMi8,SIZi8,STRMAPi8,STRINFi8,STRPNTi8,&
	&SIZ1o8,STRMAP1o8,STRINF1o8,STRPNT1o8,SIZ2o8,STRMAP2o8,STRINF2o8&
	&,STRPNT2o8,STATo8)

	USE SHARED

	REAL :: RSUMs8
	REAL, INTENT(IN) :: STRPNTi8(505,1010),STRINFi8(505,5)
	REAL, INTENT(OUT) :: STRPNT1o8(505,1010),STRPNT2o8(505,1010)
	REAL, INTENT(OUT) :: STRINF1o8(505,5),STRINF2o8(505,5)
	INTEGER :: Is8,Js8,LOCs8,CENs8,LENTHs8,Ks8,IIs8,FLAGKB,FLAGs8
	INTEGER :: NUMP1s8,NUMP2s8,NUMSs8,JJs8
	INTEGER, INTENT(IN) :: NUMi8,SIZi8,STRMAPi8(505,20),FLAGPi8
	INTEGER, INTENT(OUT) :: STRMAP1o8(505,20),STRMAP2o8(505,20)
	INTEGER, INTENT(OUT) :: SIZ1o8,SIZ2o8,STATo8

	LOCs8=NUMi8
	FLAGKB=0
	STATo8=1

S25:DO Is8=1,SIZi8
	IF (LOCs8.EQ.0) THEN
	FLAGs8=0
	DO Js8=1,FUN-1
	IF (STRMAPi8(Is8,Js8).NE.0) THEN
	FLAGs8=FLAGs8+1
	END IF
	END DO

	IF (FLAGs8.LT.2) THEN
	STATo8=-1
	RETURN
	ELSE
	FLAGKB=1
	CENs8=Is8
	EXIT
	END IF
	END IF

	LOCs8=LOCs8-STRMAPi8(Is8,2*FUN)
	IF (LOCs8.LT.0) THEN
	LOCs8=LOCs8+STRMAPi8(Is8,2*FUN)
	CENs8=Is8
	EXIT
	END IF
	END DO S25

	IF (FLAGPi8.EQ.1) THEN
	LENTHs8=STRMAPi8(CENs8,2*FUN+1)
	NUMP1s8=0
	DO Is8=1,LENTHs8
	IF (STRPNTi8(CENs8,Is8).LT.LOCs8) THEN ! *
	NUMP1s8=NUMP1s8+1
	END IF
	END DO
	NUMP2s8=STRMAPi8(CENs8,2*FUN+1)-NUMP1s8
	END IF

	STRMAP1o8(1,2*FUN-1)=STRMAPi8(CENs8,2*FUN-1)
	STRMAP1o8(1,2*FUN)=LOCs8  ! *
	STRINF1o8(1,1)=0. ! *
	DO Is8=1,FUN-1
	STRMAP1o8(1,Is8)=STRMAPi8(CENs8,Is8)  !	*
	END DO
	DO Is8=FUN,2*(FUN-1)
	STRMAP1o8(1,Is8)=0	  !	*
	END DO

S26:IF (FLAGKB.EQ.0) THEN ! *
	IF (FLAGPi8.EQ.1) THEN
 	IF (MOD(NUMP1s8,2).NE.0) THEN
	STRMAP1o8(1,2*FUN+1)=NUMP1s8+1
	STRPNT1o8(1,NUMP1s8+1)=LOCs8  ! *
	DO Is8=1,NUMP1s8
	STRPNT1o8(1,Is8)=STRPNTi8(CENs8,Is8) ! *
	END DO
	ELSE
	STRMAP1o8(1,2*FUN+1)=NUMP1s8
	DO Is8=1,NUMP1s8
	STRPNT1o8(1,Is8)=STRPNTi8(CENs8,Is8) ! *
	END DO
	END IF
	END IF

	ELSE
	Js8=1	         ! *
	DO Is8=1,FUN-1	 ! *
	Ks8=STRMAPi8(CENs8,Is8)	! *
	IF (Ks8.NE.0) THEN	 ! *
	DO IIs8=1,SIZi8	 ! *
	IF (STRMAPi8(IIs8,2*FUN-1).EQ.Ks8) THEN	! *
	JJs8=IIs8		 ! *
	EXIT			 ! *
	END IF			 ! *
	END DO			 ! *
 	DO IIs8=1,LSTRMAP ! *
	STRMAP1o8(Js8,IIs8)=STRMAPi8(JJs8,IIs8)	 ! *
	END DO			 ! *
	DO IIs8=1,LINF	 ! *
	STRINF1o8(Js8,IIs8)=STRINFi8(JJs8,IIs8)	 ! *
	END DO			 ! *
	IF (FLAGPi8.EQ.1) THEN ! *
	LENTHs8=STRMAP1o8(Js8,2*FUN+1) ! *
	DO IIs8=1,LENTHs8  ! *
	STRPNT1o8(Js8,IIs8)=STRPNTi8(JJs8,IIs8)	! *
	END DO			 ! *
	END IF			 ! *
	Js8=Js8+1		 ! *
	END IF			 ! *
	END DO			 ! *

	DO Is8=1,Js8-1	 ! *
	DO Ks8=1,2*(FUN-1) ! *
	IF (STRMAP1o8(Is8,Ks8).EQ.STRMAPi8(CENs8,2*FUN-1)) THEN	! *
	STRMAP1o8(Is8,Ks8)=0 ! *
	END IF			 ! *
	END DO			 ! *
	END DO			 ! *
	END IF 	S26  	 ! *

	IF (FLAGKB.EQ.0) THEN  ! *
	NUMSs8=1		 ! *
	ELSE			 ! *
	NUMSs8=Js8-1	 ! *
	END IF			 ! *

	Is8=1
S27:DO WHILE (Is8.LE.NUMSs8) ! *	
	DO Js8=1,2*(FUN-1)
	FLAGs8=0
	IIs8=STRMAP1o8(Is8,Js8)

	IF ((IIs8.NE.0).AND.(IIs8.NE.STRMAPi8(CENs8,2*FUN-1))) THEN

	FLAGs8=-1
	DO Ks8=1,NUMSs8
	IF (STRMAP1o8(Ks8,2*FUN-1).EQ.IIs8) THEN
	FLAGs8=1
	EXIT
	END IF
	END DO

	IF (FLAGs8.EQ.-1) THEN
	DO Ks8=1,SIZi8
	IF (STRMAPi8(Ks8,2*FUN-1).EQ.IIs8) THEN
	JJs8=Ks8
	EXIT
	END IF
	END DO

	NUMSs8=NUMSs8+1
	DO Ks8=1,LSTRMAP
	STRMAP1o8(NUMSs8,Ks8)=STRMAPi8(JJs8,Ks8)
	END DO
	DO Ks8=1,LINF
	STRINF1o8(NUMSs8,Ks8)=STRINFi8(JJs8,Ks8)
	END DO
	IF (FLAGPi8.EQ.1) THEN
	LENTHs8=STRMAPi8(JJs8,2*FUN+1)
	DO Ks8=1,LENTHs8
	STRPNT1o8(NUMSs8,Ks8)=STRPNTi8(JJs8,Ks8)
	END DO
	END IF
	END IF

	END IF

	END DO
	Is8=Is8+1
	END DO S27	  ! *

	SIZ1o8=NUMSs8

	RSUMs8=0.
	DO Is8=1,SIZ1o8
	RSUMs8=RSUMs8+STRMAP1o8(Is8,2*FUN)+STRINF1o8(Is8,1)
	END DO
	IF (RSUMs8.LE.0.) THEN
	STATo8=-1
	RETURN
	END IF

	STRMAP2o8(1,2*FUN-1)=STRMAPi8(CENs8,2*FUN-1)  ! *
	STRMAP2o8(1,2*FUN)=STRMAPi8(CENs8,2*FUN)-LOCs8 ! *
	STRINF2o8(1,1)=STRINFi8(CENs8,1)  ! *
	DO Is8=1,FUN-1		 ! *
	STRMAP2o8(1,Is8)=0	 ! *
	END DO				 ! *
	DO Is8=FUN,2*(FUN-1) ! *
	STRMAP2o8(1,Is8)=STRMAPi8(CENs8,Is8) ! *
	END DO				 ! *

    IF (FLAGKB.EQ.0) THEN	! *
	IF (FLAGPi8.EQ.1) THEN
	IF (MOD(NUMP2s8,2).NE.0) THEN
	STRMAP2o8(1,2*FUN+1)=NUMP2s8+1
	STRPNT2o8(1,1)=0	! *
	DO Is8=1,NUMP2s8
	STRPNT2o8(1,Is8+1)=STRPNTi8(CENs8,Is8+NUMP1s8)-LOCs8 ! *
	END DO
	ELSE
	STRMAP2o8(1,2*FUN+1)=NUMP2s8
	DO Is8=1,NUMP2s8
	STRPNT2o8(1,Is8)=STRPNTi8(CENs8,Is8+NUMP1s8)-LOCs8 ! *
	END DO
	END IF
	END IF
	
	ELSE
	STRMAP2o8(1,2*FUN+1)=STRMAPi8(CENs8,2*FUN+1) ! *
	IF (FLAGPi8.EQ.1) THEN	 ! *
	LENTHs8=STRMAP2o8(1,2*FUN+1) ! *
	DO Is8=1,LENTHs8		 ! *
	STRPNT2o8(1,Is8)=STRPNTi8(CENs8,Is8) ! *
	END DO					 ! *
	END IF					 ! *
	END IF  				 ! *

	NUMSs8=1				 ! *
	Is8=1
S28:DO WHILE (Is8.LE.NUMSs8) 	
	DO Js8=1,2*(FUN-1)
	FLAGs8=0
	IIs8=STRMAP2o8(Is8,Js8)

	IF ((IIs8.NE.0).AND.(IIs8.NE.STRMAPi8(CENs8,2*FUN-1))) THEN

	FLAGs8=-1
	DO Ks8=1,NUMSs8
	IF (STRMAP2o8(Ks8,2*FUN-1).EQ.IIs8) THEN
	FLAGs8=1
	EXIT
	END IF
	END DO

	IF (FLAGs8.EQ.-1) THEN
	DO Ks8=1,SIZi8
	IF (STRMAPi8(Ks8,2*FUN-1).EQ.IIs8) THEN
	JJs8=Ks8
	EXIT
	END IF
	END DO

	NUMSs8=NUMSs8+1
	DO Ks8=1,LSTRMAP
	STRMAP2o8(NUMSs8,Ks8)=STRMAPi8(JJs8,Ks8)
	END DO
	DO Ks8=1,LINF
	STRINF2o8(NUMSs8,Ks8)=STRINFi8(JJs8,Ks8)
	END DO
	IF (FLAGPi8.EQ.1) THEN
	LENTHs8=STRMAPi8(JJs8,2*FUN+1)
	DO Ks8=1,LENTHs8
	STRPNT2o8(NUMSs8,Ks8)=STRPNTi8(JJs8,Ks8)
	END DO
	END IF
	END IF

	END IF

	END DO
	Is8=Is8+1
	END DO S28

	SIZ2o8=NUMSs8	

	RSUMs8=0.
	DO Is8=1,SIZ2o8
	RSUMs8=RSUMs8+STRMAP2o8(Is8,2*FUN)+STRINF2o8(Is8,1)
	END DO
	IF (RSUMs8.LE.0.) THEN
	STATo8=-1
	RETURN
	END IF

	RETURN

	END SUBROUTINE BRKG

!==================================================================
!      SUBROUTINE 9: REJOINING
!==================================================================

	SUBROUTINE REJN(FLAGPi9,NUM1i9,SIZ1i9,STRMAP1i9,STRINF1i9,STRPNT1i9&
	&,NUM2i9,SIZ2i9,STRMAP2i9,STRINF2i9,STRPNT2i9,SIZo9,STRMAPo9,STRINFo9&
	&,STRPNTo9,STATo9)

	USE SHARED

	REAL, INTENT(IN) :: STRPNT1i9(505,1010),STRPNT2i9(505,1010)
	REAL, INTENT(IN) ::	STRINF1i9(505,5),STRINF2i9(505,5)
	REAL, INTENT(OUT) :: STRPNTo9(505,1010),STRINFo9(505,5)
	REAL :: STRPNTs9(2,505,505),XCHRs9(505),ML1s9,ML2s9,STRINFs9(2,505,5)
	INTEGER :: Is9,Js9,LOC1s9,CENs9,LENTH1s9,Ks9,SIZs9(2),LENTH2s9
	INTEGER :: SUMs9,NHT(2,2),XCHs9,STRMAPs9(2,505,20)
	INTEGER :: NUMs9(2),DMLs9,LOC2s9,IIs9
	INTEGER, INTENT(IN) :: NUM1i9,SIZ1i9,STRMAP1i9(505,20),SIZ2i9
	INTEGER, INTENT(IN) :: NUM2i9,STRMAP2i9(505,20),FLAGPi9
	INTEGER, INTENT(OUT) :: SIZo9,STRMAPo9(505,20),STATo9

	STATo9=1
	SIZs9(1)=SIZ1i9
	NUMs9(1)=NUM1i9
	SIZs9(2)=SIZ2i9
	NUMs9(2)=NUM2i9

	DO Is9=1,SIZ1i9
	DO Js9=1,LSTRMAP
	STRMAPs9(1,Is9,Js9)=STRMAP1i9(Is9,Js9)
	END DO
	DO Js9=1,LINF
	STRINFs9(1,Is9,Js9)=STRINF1i9(Is9,Js9)
	END DO
	IF (FLAGPi9.EQ.1) THEN
	LENTH1s9=STRMAPs9(1,Is9,2*FUN+1)
	DO Js9=1,LENTH1s9
	STRPNTs9(1,Is9,Js9)=STRPNT1i9(Is9,Js9)
	END DO
	END IF
	END DO

	DO Is9=1,SIZ2i9
	DO Js9=1,LSTRMAP
	STRMAPs9(2,Is9,Js9)=STRMAP2i9(Is9,Js9)
	END DO
	DO Js9=1,LINF
	STRINFs9(2,Is9,Js9)=STRINF2i9(Is9,Js9)
	END DO
	IF (FLAGPi9.EQ.1) THEN
	LENTH2s9=STRMAPs9(2,Is9,2*FUN+1)
	DO Js9=1,LENTH2s9
	STRPNTs9(2,Is9,Js9)=STRPNT2i9(Is9,Js9)
	END DO
	END IF
	END DO

 	DO Ks9=1,2
	LOC1s9=NUMs9(Ks9)
    DO Is9=1,SIZs9(Ks9)
	DO Js9=1,2
	CENs9=(Js9-1)*(FUN-1)
	SUMs9=0
	DO IIs9=1,FUN-1
	IF (STRMAPs9(Ks9,Is9,CENs9+IIs9).NE.0) THEN
	SUMs9=1
	EXIT
	END IF
	END DO

	IF (SUMs9.EQ.0)	THEN
	LOC1s9=LOC1s9-1
	IF (LOC1s9.EQ.0) THEN 
	NHT(Ks9,1)=Is9
	NHT(Ks9,2)=Js9
	GOTO 04
	END IF
	END IF
	END DO
	END DO
04	SUMs9=0
	END DO

	IF (NHT(1,2)+NHT(2,2).NE.3) THEN
	LOC2s9=NHT(2,1)
	CENs9=FUN-1
	DO Is9=1,FUN-1
	XCHs9=STRMAPs9(2,LOC2s9,Is9)
	STRMAPs9(2,LOC2s9,Is9)=STRMAPs9(2,LOC2s9,Is9+CENs9)
	STRMAPs9(2,LOC2s9,Is9+CENs9)=XCHs9
	END DO

	IF (FLAGPi9.EQ.1) THEN
	LENTH2s9=STRMAPs9(2,LOC2s9,2*FUN+1)
	DO Js9=1,LENTH2s9
	XCHRs9(Js9)=STRMAPs9(2,LOC2s9,2*FUN)+STRINFs9(2,LOC2s9,1)-STRPNTs9(2,LOC2s9,Js9)
	END DO
	DO Js9=1,LENTH2s9
	STRPNTs9(2,LOC2s9,LENTH2s9+1-Js9)=XCHRs9(Js9)
	END DO
	END IF
	END IF

	LOC1s9=NHT(1,1)
	LOC2s9=NHT(2,1)
	LENTH1s9=STRMAPs9(1,LOC1s9,2*FUN+1)
	LENTH2s9=STRMAPs9(2,LOC2s9,2*FUN+1)
	ML1s9=STRMAPs9(1,LOC1s9,2*FUN)+STRINFs9(1,LOC1s9,1)
	ML2s9=STRMAPs9(2,LOC2s9,2*FUN)+STRINFs9(2,LOC2s9,1)

	IF ((ML1s9+ML2s9.GT.STRMA).OR.(ML1s9+ML2s9.LE.0.)) THEN
!	IF (ML1s9+ML2s9.LE.0.) THEN
	STATo9=-1
	RETURN
	END IF

S29:IF (NHT(1,2).EQ.1) THEN

	DO Is9=1,SIZs9(2)
	DO Js9=1,LSTRMAP
	STRMAPo9(Is9,Js9)=STRMAPs9(2,Is9,Js9)
	END DO
	DO Js9=1,LINF
	STRINFo9(Is9,Js9)=STRINFs9(2,Is9,Js9)
	END DO
	SUMs9=STRMAPo9(Is9,2*FUN+1)
	DO Js9=1,SUMs9
	STRPNTo9(Is9,Js9)=STRPNTs9(2,Is9,Js9)
	END DO
	END DO

	STRINFo9(LOC2s9,1)=STRINFs9(2,LOC2s9,1)+STRINFs9(1,LOC1s9,1)
	IF (ABS(STRINFo9(LOC2s9,1)).GE.1.) THEN
	DMLs9=INT(STRINFo9(LOC2s9,1))
	ELSE
	DMLs9=0
	END IF

	DO Js9=1,LENTH1s9
	STRPNTo9(LOC2s9,Js9+LENTH2s9)=STRPNTs9(1,LOC1s9,Js9)+ML2s9
	END DO

	STRINFo9(LOC2s9,1)=STRINFo9(LOC2s9,1)-DMLs9
	STRMAPo9(LOC2s9,2*FUN)=STRMAPs9(2,LOC2s9,2*FUN)+STRMAPs9(1,LOC1s9,2*FUN)+DMLs9
	STRMAPo9(LOC2s9,2*FUN+1)=STRMAPs9(2,LOC2s9,2*FUN+1)+STRMAPs9(1,LOC1s9,2*FUN+1)

	Is9=0
S30:DO Js9=1,SIZs9(1)
	IF (Js9.NE.LOC1s9) THEN
	Is9=Is9+1

	DO Ks9=1,LSTRMAP
	IF ((STRMAPs9(1,Js9,Ks9).NE.0).AND.(Ks9.LE.2*FUN-1)) THEN
	IF (STRMAPs9(1,Js9,Ks9).EQ.STRMAPs9(1,LOC1s9,2*FUN-1)) THEN
	STRMAPo9(SIZs9(2)+Is9,Ks9)=STRMAPo9(LOC2s9,2*FUN-1)
	ELSE
	STRMAPo9(SIZs9(2)+Is9,Ks9)=STRMAPs9(1,Js9,Ks9)+SIZs9(2)
	END IF

	ELSE
	STRMAPo9(SIZs9(2)+Is9,Ks9)=STRMAPs9(1,Js9,Ks9)
	END IF
	END DO 

	DO Ks9=1,LINF
	STRINFo9(SIZs9(2)+Is9,Ks9)=STRINFs9(1,Js9,Ks9)
	END DO

	IF (FLAGPi9.EQ.1) THEN
	SUMs9=STRMAPo9(SIZs9(2)+Is9,2*FUN+1)
	DO Ks9=1,SUMs9
	STRPNTo9(SIZs9(2)+Is9,Ks9)=STRPNTs9(1,Js9,Ks9)
	END DO
	END IF

	END IF
	END DO S30

 	DO Js9=FUN,2*(FUN-1)
	IF (STRMAPs9(1,LOC1s9,Js9).NE.0) THEN
	STRMAPo9(LOC2s9,Js9)=STRMAPs9(1,LOC1s9,Js9)+SIZs9(2)
	ELSE
	STRMAPo9(LOC2s9,Js9)=STRMAPs9(1,LOC1s9,Js9)
	END IF
	END DO

	SIZo9=SIZs9(1)+SIZs9(2)-1

	ELSE
	DO Is9=1,SIZs9(1)
	DO Js9=1,LSTRMAP
	STRMAPo9(Is9,Js9)=STRMAPs9(1,Is9,Js9)
	END DO
	DO Js9=1,LINF
	STRINFo9(Is9,Js9)=STRINFs9(1,Is9,Js9)
	END DO
	SUMs9=STRMAPo9(Is9,2*FUN+1)
	DO Js9=1,SUMs9
	STRPNTo9(Is9,Js9)=STRPNTs9(1,Is9,Js9)
	END DO
	END DO

	STRINFo9(LOC1s9,1)=STRINFs9(2,LOC2s9,1)+STRINFs9(1,LOC1s9,1)
	IF (ABS(STRINFo9(LOC1s9,1)).GE.1.) THEN
	DMLs9=INT(STRINFo9(LOC1s9,1))
	ELSE
	DMLs9=0
	END IF

	DO Js9=1,LENTH2s9
	STRPNTo9(LOC1s9,Js9+LENTH1s9)=STRPNTs9(2,LOC2s9,Js9)+ML1s9
	END DO

	STRINFo9(LOC1s9,1)=STRINFo9(LOC1s9,1)-DMLs9
	STRMAPo9(LOC1s9,2*FUN)=STRMAPs9(2,LOC2s9,2*FUN)+STRMAPs9(1,LOC1s9,2*FUN)+DMLs9
	STRMAPo9(LOC1s9,2*FUN+1)=STRMAPs9(2,LOC2s9,2*FUN+1)+STRMAPs9(1,LOC1s9,2*FUN+1)

	Is9=0
S31:DO Js9=1,SIZs9(2)
	IF (Js9.NE.LOC2s9) THEN
	Is9=Is9+1

	DO Ks9=1,LSTRMAP
	IF ((STRMAPs9(2,Js9,Ks9).NE.0).AND.(Ks9.LE.2*FUN-1)) THEN
	IF (STRMAPs9(2,Js9,Ks9).EQ.STRMAPs9(2,LOC2s9,2*FUN-1)) THEN
	STRMAPo9(SIZs9(1)+Is9,Ks9)=STRMAPo9(LOC1s9,2*FUN-1)
	ELSE
	STRMAPo9(SIZs9(1)+Is9,Ks9)=STRMAPs9(2,Js9,Ks9)+SIZs9(1)
	END IF

	ELSE
	STRMAPo9(SIZs9(1)+Is9,Ks9)=STRMAPs9(2,Js9,Ks9)
	END IF
	END DO 

	DO Ks9=1,LINF
	STRINFo9(SIZs9(1)+Is9,Ks9)=STRINFs9(2,Js9,Ks9)
	END DO

	SUMs9=STRMAPo9(SIZs9(1)+Is9,2*FUN+1)
	DO Ks9=1,SUMs9
	STRPNTo9(SIZs9(1)+Is9,Ks9)=STRPNTs9(2,Js9,Ks9)
	END DO

	END IF
	END DO S31

  	DO Js9=FUN,2*(FUN-1)
	IF (STRMAPs9(2,LOC2s9,Js9).NE.0) THEN
	STRMAPo9(LOC1s9,Js9)=STRMAPs9(2,LOC2s9,Js9)+SIZs9(1)
	ELSE
	STRMAPo9(LOC1s9,Js9)=STRMAPs9(2,LOC2s9,Js9)
	END IF
	END DO

	SIZo9=SIZs9(1)+SIZs9(2)-1

	END IF S29

	RETURN

	END SUBROUTINE REJN

!==================================================================
!      SUBROUTINE 10: REFRESH OF MICELLE INFORMATION
!==================================================================

	SUBROUTINE RFMAP(SIZi10,STRMAPi10,STRINFi10,LMAPo10,FMAPo10,STRINFo10)

	USE SHARED

 	REAL, INTENT(IN) :: STRINFi10(505,5)
	REAL, INTENT(OUT) :: FMAPo10(5),STRINFo10(505,5)
	INTEGER :: Is10,Js10,Ks10,IIs10,JJs10,CENs10,SUMs10,BRP(505,7)
	INTEGER :: MAXs10,XCHs10,FLAGs10
	INTEGER, INTENT(IN) :: SIZi10,STRMAPi10(505,20)
 	INTEGER, INTENT(OUT) :: LMAPo10(15)

	LMAPo10(1)=0
	LMAPo10(2)=0
	LMAPo10(3)=0
	LMAPo10(4)=0
	LMAPo10(5)=0
	LMAPo10(6)=SIZi10
	FMAPo10(2)=0.

	DO Is10=1,SIZi10
	DO Js10=1,LINF
	STRINFo10(Is10,Js10)=STRINFi10(Is10,Js10)
	END DO
	END DO

	DO Is10=1,SIZi10
	FMAPo10(2)=FMAPo10(2)+STRINFi10(Is10,1)
	END DO

	IF (SIZi10.GT.2) THEN
	LMAPo10(1)=1
	END IF

	IIs10=1
S32:DO Is10=1,SIZi10
	LMAPo10(2)=LMAPo10(2)+STRMAPi10(Is10,2*FUN)
	DO Js10=1,2
	CENs10=(Js10-1)*(FUN-1)
	SUMs10=0

	DO Ks10=1,FUN-1
	IF (STRMAPi10(Is10,Ks10+CENs10).NE.0) THEN
	SUMs10=SUMs10+1
	END IF
	END DO

S33:IF (SUMs10.GT.1) THEN
	BRP(IIs10,1)=STRMAPi10(Is10,2*FUN-1)
	DO Ks10=1,FUN-1
	BRP(IIs10,Ks10+1)=STRMAPi10(Is10,Ks10+CENs10)
	END DO

	DO Ks10=1,FUN-1
	MAXs10=BRP(IIs10,Ks10)
	DO JJs10=Ks10+1,FUN 
	IF (MAXs10.LT.BRP(IIs10,JJs10)) THEN
	MAXs10=BRP(IIs10,JJs10)
	XCHs10=BRP(IIs10,Ks10)
	BRP(IIs10,Ks10)=BRP(IIs10,JJs10)
	BRP(IIs10,JJs10)=XCHs10
	END IF
	END DO
	END DO

	DO Ks10=1,IIs10-1
	FLAGs10=0
	DO JJs10=1,FUN
	IF (BRP(IIs10,JJs10).EQ.BRP(Ks10,JJs10)) THEN
	FLAGs10=FLAGs10+1
	END IF
	END DO
	IF (FLAGs10.EQ.FUN) THEN
	GOTO 05
	END IF
	END DO

	IIs10=IIs10+1
	END IF S33

05	IF (SUMs10.EQ.0) THEN
	LMAPo10(5)=LMAPo10(5)+1
	END IF
	END DO
	END DO S32

	DO Is10=1,IIs10-1
	FLAGs10=0
	DO Js10=1,FUN
	IF (BRP(Is10,Js10).NE.0) THEN
	FLAGs10=FLAGs10+1
	END IF
	END DO
	IF (FLAGs10.EQ.3) THEN
	LMAPo10(3)=LMAPo10(3)+1
	END IF
	IF (FLAGs10.EQ.4) THEN
	LMAPo10(4)=LMAPo10(4)+1
	END IF
	END DO

S34:IF (LMAPo10(1).EQ.0) THEN
	STRINFo10(1,2)=1.
	STRINFo10(1,3)=-1.
	STRINFo10(1,4)=-1.

	ELSE
	DO Is10=1,SIZi10
	FLAGs10=0

	DO Js10=1,2	
	CENs10=(Js10-1)*(FUN-1)
	SUMs10=0
	DO Ks10=1,FUN-1
	IF (STRMAPi10(Is10,CENs10+Ks10).EQ.0) THEN
	SUMs10=SUMs10+1
	END IF
	END DO
	IF (SUMs10.EQ.FUN-1) THEN
	FLAGs10=FLAGs10+1
	END IF
	END DO

	IF (FLAGs10.EQ.1) THEN 
	STRINFo10(Is10,2)=-1.
	STRINFo10(Is10,3)=1.
	STRINFo10(Is10,4)=-1.
	END IF
	IF (FLAGs10.EQ.0) THEN 
	STRINFo10(Is10,2)=-1.
	STRINFo10(Is10,3)=-1.
	STRINFo10(Is10,4)=1.
	END IF

	END DO
	END IF S34

	RETURN

	END SUBROUTINE RFMAP

!==================================================================
!      SUBROUTINE 11: MOVEMENT OF POINTERS DUE TO RELAXATION
!==================================================================

	SUBROUTINE MPDR(SIZi11,STRMAPi11,STRINFi11,STRPNTi11,STRMAPo11,&
	&STRPNTo11)

	USE SHARED

	REAL :: MLs11,LHs11,LTs11,DLF,DLR,RNDs11
    REAL, INTENT(IN) ::	STRPNTi11(505,707),STRINFi11(505,5)
    REAL, INTENT(OUT) ::STRPNTo11(505,707)
	INTEGER :: Is11,Js11,Ks11,LENTHs11,NUMPs11,FLAGs11,CENs11
	INTEGER, INTENT(IN) :: SIZi11,STRMAPi11(505,20)
 	INTEGER, INTENT(OUT) :: STRMAPo11(505,20)

	DO Is11=1,SIZi11
	DO Js11=1,LSTRMAP
	STRMAPo11(Is11,Js11)=STRMAPi11(Is11,Js11)
	END DO	
	LENTHs11=STRMAPo11(Is11,2*FUN+1)
	DO Js11=1,LENTHs11
	STRPNTo11(Is11,Js11)=STRPNTi11(Is11,Js11)
	END DO
	END DO

S35:DO Is11=1,SIZi11
	DO Ks11=1,2
	IF (STRMAPo11(Is11,2*FUN+1).GT.0) THEN	
	CENs11=(Ks11-1)*(FUN-1)
	FLAGs11=0

	DO Js11=1,FUN-1
	IF (STRMAPo11(Is11,Js11+CENs11).NE.0) THEN
	FLAGs11=1
	EXIT
	END IF
	END DO

S36:IF (FLAGs11.EQ.0) THEN
	MLs11=STRINFi11(Is11,1)+STRMAPo11(Is11,2*FUN)
	IF (Ks11.EQ.1) THEN
	LENTHs11=STRMAPo11(Is11,2*FUN+1)
 	LHs11=STRPNTo11(Is11,1)

	IF (LHs11.GT.0.2) THEN
	DLF=LHs11
	DO Js11=1,20
	DLF=COEF_F/(LHs11+DLF/2.)**3.
	END DO
	ELSE
	DLF=CNST_F
	END IF
	STRPNTo11(Is11,1)=STRPNTo11(Is11,1)+DLF

	IF (STRPNTo11(Is11,1).GE.STRPNTo11(Is11,2)) THEN
 	DO Js11=3,LENTHs11
	STRPNTo11(Is11,Js11-2)=STRPNTo11(Is11,Js11)
	END DO
	STRMAPo11(Is11,2*FUN+1)=STRMAPo11(Is11,2*FUN+1)-2
	END IF

	ELSE
	LENTHs11=STRMAPo11(Is11,2*FUN+1)
	LTs11=MLs11-STRPNTo11(Is11,LENTHs11)
	IF (LTs11.GT.0.2) THEN
	DLF=LTs11
	DO Js11=1,20
	DLF=COEF_F/(LTs11+DLF/2.)**3.
	END DO
	ELSE
	DLF=CNST_F
	END IF
	STRPNTo11(Is11,LENTHs11)=STRPNTo11(Is11,LENTHs11)-DLF

	IF (STRPNTo11(Is11,LENTHs11).LE.STRPNTo11(Is11,LENTHs11-1)) THEN
	STRMAPo11(Is11,2*FUN+1)=STRMAPo11(Is11,2*FUN+1)-2
	END IF
	END IF
	END IF S36

	END IF
	END DO
	END DO S35

S37:IF (SIZi11.LT.3) THEN
	DO Is11=1,SIZi11
	IF (STRMAPo11(Is11,2*FUN+1).GT.0) THEN
	MLs11=STRINFi11(Is11,1)+STRMAPo11(Is11,2*FUN)
	LENTHs11=STRMAPo11(Is11,2*FUN+1)
	DLR=SQRT(CNST_R/MLs11)
	CALL RANDOM_NUMBER(RNDs11)

S38:IF (RNDs11.LE.0.5) THEN
	DO Js11=1,LENTHs11
	STRPNTo11(Is11,Js11)=STRPNTo11(Is11,Js11)+DLR
	END DO

	NUMPs11=0
	DO Js11=1,LENTHs11
	IF (STRPNTo11(Is11,Js11).LE.MLs11)	THEN
	NUMPs11=NUMPs11+1
	END IF
	END DO
	IF (MOD(NUMPs11,2).NE.0) THEN
	STRMAPo11(Is11,2*FUN+1)=NUMPs11+1
	STRPNTo11(Is11,NUMPs11+1)=MLs11
	ELSE
    STRMAPo11(Is11,2*FUN+1)=NUMPs11
	END IF

	ELSE
	DO Js11=1,LENTHs11
	STRPNTo11(Is11,Js11)=STRPNTo11(Is11,Js11)-DLR
	END DO

	NUMPs11=0
	DO Js11=1,LENTHs11
	IF (STRPNTo11(Is11,Js11).LT.0)	THEN
	NUMPs11=NUMPs11+1
	END IF
	END DO
	IF (MOD(NUMPs11,2).NE.0) THEN
	STRMAPo11(Is11,2*FUN+1)=STRMAPo11(Is11,2*FUN+1)-NUMPs11+1
	STRPNTo11(Is11,1)=0.
	DO Js11=NUMPs11+1,LENTHs11
	STRPNTo11(Is11,Js11-NUMPs11+1)=STRPNTo11(Is11,Js11)
	END DO
	ELSE
    STRMAPo11(Is11,2*FUN+1)=STRMAPo11(Is11,2*FUN+1)-NUMPs11
	DO Js11=NUMPs11+1,LENTHs11
	STRPNTo11(Is11,Js11-NUMPs11)=STRPNTo11(Is11,Js11)
	END DO
	END IF

	END IF S38
	END IF
	END DO
	END IF S37

S51:DO Is11=1,SIZi11
	IF (STRMAPo11(Is11,2*FUN+1).GT.0) THEN
	LENTHs11=STRMAPo11(Is11,2*FUN+1)

	Js11=1
S52:DO WHILE (Js11.LE.LENTHs11-1)
	IF (STRPNTo11(Is11,Js11).EQ.STRPNTo11(Is11,Js11+1)) THEN
	DO Ks11=Js11,LENTHs11-2
	STRPNTo11(Is11,Ks11)=STRPNTo11(Is11,Ks11+2)
	END DO
	LENTHs11=LENTHs11-2
	ELSE
	Js11=Js11+2
	END IF
	END DO S52

	Js11=2
S53:DO WHILE (Js11.LE.LENTHs11-1)
	IF (STRPNTo11(Is11,Js11).EQ.STRPNTo11(Is11,Js11+1)) THEN
	DO Ks11=Js11,LENTHs11-2
	STRPNTo11(Is11,Ks11)=STRPNTo11(Is11,Ks11+2)
	END DO
	LENTHs11=LENTHs11-2
	ELSE
	Js11=Js11+2
	END IF
	END DO S53

	STRMAPo11(Is11,2*FUN+1)=LENTHs11
	END IF
	END DO S51

	RETURN

	END SUBROUTINE MPDR

!==================================================================
!      SUBROUTINE 12: DETERMINE MICELLE/STRAND DISTRIBUTION 
!==================================================================

	SUBROUTINE LDSTB(FLAGi12)
 
	USE SHARED

	INTEGER :: Is12,Js12,Ks12,IIs12,JJs12,LENTHs12,FLAGs12,LOCs12,KKs12
	INTEGER, INTENT(IN) :: FLAGi12

	IF (FLAGi12.EQ.0) THEN
	NUMDTR=0
	MDTR1=0
	SDTR1=0
	MDTR2=0.
	SDTR2=0.

	FDTR1=0
	FDTR2=0.
	FUMDTR=0
	RETURN
	END IF

	IIs12=1+NUMDTR(1)
S39:DO Is12=1,NUM+NLF
	LENTHs12=CEILING(FMAP(Is12,2)+LMAP(Is12,2))

	FLAGs12=0
	DO Ks12=1,IIs12-1
	IF (MDTR1(Ks12,1).EQ.LENTHs12) THEN
	MDTR1(Ks12,2)=MDTR1(Ks12,2)+1
	MDTR2(Ks12,1)=MDTR2(Ks12,1)+LMAP(Is12,3)
	MDTR2(Ks12,2)=MDTR2(Ks12,2)+LMAP(Is12,4)
	FLAGs12=1
	EXIT
	END IF
	END DO

	IF (FLAGs12.EQ.0) THEN
	LOCs12=0
	DO Js12=1,IIs12-1
	IF (MDTR1(Js12,1).GT.LENTHs12) THEN
	LOCs12=Js12
	EXIT
	END IF
	END DO
	IF (LOCs12.EQ.0) THEN
	LOCs12=IIs12
	END IF

	DO Js12=LOCs12,IIs12-1
	Ks12=IIs12-1+LOCs12-Js12
	DO JJs12=1,2
	MDTR1(Ks12+1,JJs12)=MDTR1(Ks12,JJs12)
	END DO
	DO JJs12=1,2
	MDTR2(Ks12+1,JJs12)=MDTR2(Ks12,JJs12)
	END DO
	END DO

  	MDTR1(LOCs12,1)=LENTHs12
	MDTR1(LOCs12,2)=1
	MDTR2(LOCs12,1)=LMAP(Is12,3)
	MDTR2(LOCs12,2)=LMAP(Is12,4)
	IIs12=IIs12+1
	END IF
	END DO S39

	NUMDTR(1)=IIs12-1

	IIs12=1+NUMDTR(2)
S40:DO Is12=1,NUMSTR
	LENTHs12=CEILING(STRINF(Is12,1)+STRMAP(Is12,2*FUN))	

	FLAGs12=0
	DO Ks12=1,IIs12-1
	IF (SDTR1(Ks12,1).EQ.LENTHs12) THEN
	SDTR1(Ks12,2)=SDTR1(Ks12,2)+1
	DO KKs12=2,4
	IF (STRINF(Is12,KKs12).GT.0.) THEN
	SDTR2(Ks12,KKs12-1)=SDTR2(Ks12,KKs12-1)+STRINF(Is12,KKs12)
	END IF
	END DO
	FLAGs12=1
	EXIT
	END IF
	END DO

	IF (FLAGs12.EQ.0) THEN
	LOCs12=0
	DO Js12=1,IIs12-1
	IF (SDTR1(Js12,1).GT.LENTHs12) THEN
	LOCs12=Js12
	EXIT
	END IF
	END DO
	IF (LOCs12.EQ.0) THEN
	LOCs12=IIs12
	END IF

	DO Js12=LOCs12,IIs12-1
	Ks12=IIs12-1+LOCs12-Js12
	DO JJs12=1,2
	SDTR1(Ks12+1,JJs12)=SDTR1(Ks12,JJs12)
	END DO
	DO JJs12=1,3
	SDTR2(Ks12+1,JJs12)=SDTR2(Ks12,JJs12)
	END DO
	END DO

  	SDTR1(LOCs12,1)=LENTHs12
	SDTR1(LOCs12,2)=1
	DO KKs12=2,4
	IF (STRINF(Is12,KKs12).GT.0.) THEN
	SDTR2(LOCs12,KKs12-1)=STRINF(Is12,KKs12)
	END IF
	END DO
	IIs12=IIs12+1
	END IF

	END DO S40

	NUMDTR(2)=IIs12-1

S48:DO KKs12=1,3
	IIs12=1+FUMDTR(KKs12)
S49:DO Is12=1,NUMSTR
	IF (STRINF(Is12,1+KKs12).GT.0) THEN
	LENTHs12=CEILING(STRINF(Is12,1)+STRMAP(Is12,2*FUN))	

!	IF ((LENTHs12.LE.0.).OR.(LENTHs12.GT.STRMA)) THEN
!	WRITE(*,*) 'PROBLEM FOUND: ',LENTHs12
!	WRITE(*,*) STRINF(Is12,1),STRMAP(Is12,2*FUN)
!	PAUSE
!	END IF

	FLAGs12=0
	DO Ks12=1,IIs12-1
	IF (FDTR1(Ks12,KKs12).EQ.LENTHs12) THEN
 	FDTR2(Ks12,KKs12)=FDTR2(Ks12,KKs12)+STRINF(Is12,KKs12+1)
	FLAGs12=1
	EXIT
	END IF
	END DO

	IF (FLAGs12.EQ.0) THEN
	LOCs12=0
	DO Js12=1,IIs12-1
	IF (FDTR1(Js12,KKs12).GT.LENTHs12) THEN
	LOCs12=Js12
	EXIT
	END IF
	END DO
	IF (LOCs12.EQ.0) THEN
	LOCs12=IIs12
	END IF

	DO Js12=LOCs12,IIs12-1
	Ks12=IIs12-1+LOCs12-Js12
	FDTR1(Ks12+1,KKs12)=FDTR1(Ks12,KKs12)
	FDTR2(Ks12+1,KKs12)=FDTR2(Ks12,KKs12)
	END DO

  	FDTR1(LOCs12,KKs12)=LENTHs12
	FDTR2(LOCs12,KKs12)=STRINF(Is12,KKs12+1)
	IIs12=IIs12+1
	END IF
	
	END IF
	END DO S49
	FUMDTR(KKs12)=IIs12-1
	END DO S48

	RETURN 

	END	SUBROUTINE LDSTB

!==================================================================
!      SUBROUTINE 13: REFLRESH LIST OF MICELLE
!==================================================================

	SUBROUTINE RFLM(NUMi13)
 
	USE SHARED

	INTEGER :: Is13,Js13,LOCs13
	INTEGER, INTENT(IN) :: NUMi13

	LOCs13=NUMi13
    DO Is13=LOCs13,NUM+NLF
	DO Js13=1,LLMAP
 	LMAP(Is13,Js13)=LMAP(Is13+1,Js13)
	END DO
	DO Js13=1,LFMAP
 	FMAP(Is13,Js13)=FMAP(Is13+1,Js13)
	END DO
	END DO

	RETURN

	END	SUBROUTINE RFLM

!==================================================================
!      SUBROUTINE 14: GENERATE G(t) 
!==================================================================

	SUBROUTINE GGT(Ni14,G1i14,G2i14)
 
	USE SHARED

    REAL, INTENT(IN) :: G1i14,G2i14
	INTEGER :: FLAGs14
	INTEGER, INTENT(IN)	:: Ni14

S41:IF (G2i14.GT.SQRT(0.1)) THEN
	FLAGs14=0
    IF (Ni14.EQ.Nt0) THEN
	BDIND=Nt0*DT
	NIND=0
	ELSE
	IF (FLOOR(LOG10(Ni14*DT)).EQ.CEILING(LOG10((Ni14-1)*DT))) THEN
	BDIND=Ni14*DT
	NIND=0
	END IF
	END IF
	
	ELSE
	FLAGs14=1
	IF (G1i14.GT.SQRT(0.1)) THEN 	
	BDIND=G2i14
	NIND=0
	ELSE
 	IF (FLOOR(LOG10(G2i14)).EQ.CEILING(LOG10(G1i14))) THEN
	BDIND=G2i14
	NIND=0
	END IF
	END IF
	END IF S41

	IF (FLAGs14.EQ.0) THEN				 ! WRITTING TIME DOMAIN DATA IN THE TEMPORARY FILE
	IF (Ni14*DT.GE.BDIND*10.**(INDEX*NIND)) THEN	
	WRITE(19,*)	Ni14,Ni14*DT,G2i14
	NIND=NIND+1
	T(NUMG)=Ni14*DT
	G(NUMG)=G2i14
	NUMG=NUMG+1
	END IF
	ELSE
 	IF (G2i14.LE.BDIND/10.**(INDEX*NIND)) THEN	
	WRITE(19,*)	Ni14,Ni14*DT,G2i14
	NIND=NIND+1
	T(NUMG)=Ni14*DT
	G(NUMG)=G2i14
	NUMG=NUMG+1
	END IF
	END IF 

	RETURN 

	END	SUBROUTINE GGT

!==================================================================
!      SUBROUTINE 15: GENETIC ALGORITHM 
!==================================================================

	SUBROUTINE GEAM(FLAGi15,No15,Mo15,To15,ERRMo15)

 	USE SHARED

	REAL :: RNDs15,MIU(505,40),IND1s15,IND2s15,TAO(505,40),OPT,Ds15,ERRSD(20)
	REAL :: RSUMs15,ERR(505),MINs15,R1s15,R2s15,CRs15,RA1s15,RA2s15,BDRs15(2,40)
	REAL :: XCHMs15(2,2,40),SEEDs15(20,2,40),OPT0,CNSTRs15
	REAL, INTENT(OUT) :: Mo15(40),To15(40),ERRMo15
	INTEGER :: Is15,Js15,Ks15,IIs15,JJs15,RESCALE1,RESCALE2,CHECK,POINT,N0s15
	INTEGER :: XCHs15,Ms15,PT1(2),PT2(2),NMOD(505),LOCs15(2),FLAGs15,NMSD(20)
	INTEGER :: COUNT
	INTEGER, INTENT(IN) :: FLAGi15
	INTEGER, INTENT(OUT) :: No15

	CRs15=3.
	RA1s15=LOG(G(NUMG)/10.) ! *
	RA2s15=LOG(1.)	 ! *
	N0s15=FLOOR(0.5*(tMAX-tMIN))
	CNSTRs15=0.01

S42:DO Is15=1,SAMPLE			  ! GENERATE RANDOM ENSEMBLE FOR GA FITTING PARAMETERS
 	CALL RANDOM_NUMBER(RNDs15)
	NMOD(Is15)=CEILING(RNDs15*(N0s15-2)+1.25)
	DO Js15=1,NMOD(Is15)     
	CALL RANDOM_NUMBER(RNDs15)
	MIU(Is15,Js15)=RNDs15*RA2s15+(1-RNDs15)*RA1s15
	IF (FLAGi15.EQ.0) THEN

07	CALL RANDOM_NUMBER(RNDs15)
	RSUMs15=RNDs15*tMAX+(1-RNDs15)*tMIN
	XCHMs15=0.
	DO IIs15=1,Js15-1
	XCHMs15(1,1,IIs15)=TAO(Is15,IIs15)
	END DO

	IIs15=Js15-1
	DO WHILE (IIs15.GT.0)
	IF (RSUMs15.EQ.XCHMs15(1,1,IIs15)) THEN
	GOTO 07
	END IF
	IF (RSUMs15.LT.XCHMs15(1,1,IIs15)) THEN
	XCHMs15(1,1,IIs15+1)=XCHMs15(1,1,IIs15)
	IF (IIs15.EQ.1) THEN
	XCHMs15(1,1,1)=RSUMs15
	END IF
	END IF
	IF (RSUMs15.GT.XCHMs15(1,1,IIs15)) THEN
	XCHMs15(1,1,IIs15+1)=RSUMs15
	EXIT
	END IF
	IIs15=IIs15-1
	END DO

	IF (Js15.EQ.1) THEN
	TAO(Is15,Js15)=RSUMs15
	ELSE
	DO IIs5=1,Js15
	TAO(Is15,IIs15)=XCHMs15(1,1,IIs15)
	END DO
	END IF

	ELSE
	TAO(Is15,Js15)=EXP((tMAX-tMIN)/N0s15*(Js15-0.5)+tMIN) 
	END IF
	END DO
	DO Js15=1,NMOD(Is15)
	TAO(Is15,Js15)=EXP(TAO(Is15,Js15))
	END DO
	END DO S42


	ERRSD=1000.
S43:DO Ks15=1,GENERATION 	! EVOLUATION OF THE FITTING ENSEMBLE 


S44:DO Is15=1,SAMPLE			! NORMALIZE THE FITTING ENSEMBLE 
	RESCALE1=1
	RESCALE2=1
	CHECK=1

	JJs15=0
S45:DO WHILE ((CHECK+RESCALE1+RESCALE2).NE.0)
	JJs15=JJs15+1

	DO Js15=1,NMOD(Is15)
	IF (Js15.EQ.1) THEN
	BDRs15(1,Js15)=tMIN
	ELSE
	BDRs15(1,Js15)=BDRs15(2,Js15-1)
	END IF
 	IF (Js15.EQ.NMOD(Is15)) THEN
	BDRs15(2,Js15)=tMAX
	ELSE
	BDRs15(2,Js15)=(LOG(TAO(Is15,Js15))+LOG(TAO(Is15,Js15+1)))/2.
	END IF
	END DO

	CALL RANDOM_NUMBER(RNDs15)
	POINT=CEILING(RNDs15*(NMOD(Is15)-1)+0.25)

	MIU(Is15,1)=MAX(MIU(Is15,1),RA1s15)
	MIU(Is15,1)=MIN(MIU(Is15,1),RA2s15)
	MIU(Is15,NMOD(Is15))=MAX(MIU(Is15,NMOD(Is15)),RA1s15)
	MIU(Is15,NMOD(Is15))=MIN(MIU(Is15,NMOD(Is15)),RA2s15)

	DO Js15=1,POINT-1
	Ds15=ABS(MIU(Is15,Js15+1)-MIU(Is15,Js15))
	IF (Ds15.GT.CRs15) THEN
	RESCALE1=1
	CALL RANDOM_NUMBER(RNDs15)
	Ds15=CRs15*(RNDs15*2.-1.)
	MIU(Is15,Js15+1)=Ds15+MIU(Is15,Js15)
    MIU(Is15,Js15+1)=MAX(MIU(Is15,Js15+1),RA1s15)
    MIU(Is15,Js15+1)=MIN(MIU(Is15,Js15+1),RA2s15)
	END IF
	END DO

	DO Js15=1,NMOD(Is15)-POINT
    Ds15=ABS(MIU(Is15,NMOD(Is15)+1-Js15)-MIU(Is15,NMOD(Is15)-Js15))
	IF (Ds15.GT.CRs15) THEN
	RESCALE1=1
	CALL RANDOM_NUMBER(RNDs15)
	Ds15=CRs15*(RNDs15*2.-1.)
	MIU(Is15,NMOD(Is15)-Js15)=Ds15+MIU(Is15,NMOD(Is15)-Js15)
	MIU(Is15,NMOD(Is15)-Js15)=MAX(MIU(Is15,NMOD(Is15)-Js15),RA1s15)
	MIU(Is15,NMOD(Is15)-Js15)=MIN(MIU(Is15,NMOD(Is15)-Js15),RA2s15)
	END IF
	END DO
	CHECK=0		

	RSUMs15=0.
	DO Js15=1,NMOD(Is15)
    RSUMs15=RSUMs15+EXP(MIU(Is15,Js15))  ! *					
	END DO

    IF (ABS(RSUMs15-1.).LT.CNSTRs15) THEN	   ! *
	RESCALE1=0
	ELSE
	RESCALE2=1
	R1s15=LOG(1./RSUMs15)	   ! *
 
 	DO Js15=1,NMOD(Is15)
	MIU(Is15,Js15)=MIU(Is15,Js15)+R1s15	 ! *
 	MIU(Is15,Js15)=MIN(MIU(Is15,Js15),RA2s15)
	MIU(Is15,Js15)=MAX(MIU(Is15,Js15),RA1s15)
	END DO
	END IF  

	RSUMs15=0.
 	DO Js15=1,NMOD(Is15)
	IF (MIU(Is15,Js15)-T(NUMG)/TAO(Is15,Js15).GT.-20.) THEN
	RSUMs15=RSUMs15+EXP(MIU(Is15,Js15)-T(NUMG)/TAO(Is15,Js15))
	END IF
	END DO

    DO WHILE (RSUMs15.EQ.0.)
	TAO(Is15,NMOD(Is15))=EXP((LOG(TAO(Is15,NMOD(Is15)))+tMAX)/2.)
 	RSUMs15=0.
	DO Js15=1,NMOD(Is15)
	IF (MIU(Is15,Js15)-T(NUMG)/TAO(Is15,Js15).GT.-20.) THEN
	RSUMs15=RSUMs15+EXP(MIU(Is15,Js15)-T(NUMG)/TAO(Is15,Js15))
	END IF
	END DO
	END DO 

    IF (ABS(RSUMs15-G(NUMG))/G(NUMG).LT.CNSTRs15) THEN
    RESCALE2=0	

	ELSE
	R1s15=LOG(G(NUMG)/RSUMs15)	
		
	DO Js15=1,NMOD(Is15)
	IF (MIU(Is15,Js15)-T(NUMG)/TAO(Is15,Js15).GT.-20.) THEN
	IND1s15=MAX(RA1s15-MIU(Is15,Js15),MIN(R1s15,0.))  ! *	
	IND2s15=MIN(RA2s15-MIU(Is15,Js15),MAX(R1s15,0.))	! *
	CALL RANDOM_NUMBER(RNDs15)	
	R2s15=(1.-RNDs15)*IND1s15+RNDs15*IND2s15
	MIU(Is15,Js15)=MIU(Is15,Js15)+R2s15	
	TAO(Is15,Js15)=1./(1./TAO(Is15,Js15)-(R1s15-R2s15)/T(NUMG)) 
 	TAO(Is15,Js15)=MIN(TAO(Is15,Js15),EXP(BDRs15(2,Js15)))
	TAO(Is15,Js15)=MAX(TAO(Is15,Js15),EXP(BDRs15(1,Js15)))
	CHECK=1	
	END IF
	END DO
	END IF 
		
	END DO S45

  	END DO S44

    DO Is15=1,SAMPLE		! CALCULATE THE FITNESS 
	ERR(Is15)=0.
	DO Js15=1,NUMG
	GF(Js15)=0.
	DO IIs15=1,NMOD(Is15)
	R1s15=MIU(Is15,IIs15)-T(Js15)/TAO(Is15,IIs15)
	IF (R1s15.GT.-20.) THEN
    GF(Js15)=GF(Js15)+EXP(MIU(Is15,IIs15)-T(Js15)/TAO(Is15,IIs15))
	END IF
	END DO
	IF (Ks15.EQ.1) THEN
	ERR(Is15)=ERR(Is15)+ABS(G(Js15)-GF(Js15))/G(Js15)
	ELSE
	ERR(Is15)=ERR(Is15)+(G(Js15)-GF(Js15))**2./G(Js15)**2./OPT*NUMG
	END IF
	END DO
	END DO 

	DO Is15=1,SAMPLE-1		  ! REORDER THE ENSEMBLE BASED ON THE FITNESS 
	MINs15=ERR(Is15)
	Ms15=Is15
	DO Js15=Is15,SAMPLE
	IF (ERR(Js15).LT.MINs15) THEN
	MINs15=ERR(Js15)
	ERR(Js15)=ERR(Is15)
	ERR(Is15)=MINs15
	Ms15=Js15
	END IF
	END DO
	XCHs15=NMOD(Is15)
	DO Js15=1,XCHs15
	XCHMs15(1,1,Js15)=MIU(Is15,Js15)
	XCHMs15(1,2,Js15)=TAO(Is15,Js15)
	END DO
	NMOD(Is15)=NMOD(Ms15)
	DO Js15=1,NMOD(Is15)
	MIU(Is15,Js15)=MIU(Ms15,Js15)
	TAO(Is15,Js15)=TAO(Ms15,Js15)
	END DO
	NMOD(Ms15)=XCHs15
	DO Js15=1,NMOD(Ms15)
	MIU(Ms15,Js15)=XCHMs15(1,1,Js15)
	TAO(Ms15,Js15)=XCHMs15(1,2,Js15)
	END DO
	END DO

	FLAGs15=1
	IIs15=1
    DO WHILE (FLAGs15.EQ.1)	     ! KEEP THE SEEDS
	FLAGs15=0
	DO Is15=1,NSEED
	IF (ERR(IIs15).LE.ERRSD(Is15)) THEN

	NMSD(Is15)=NMOD(IIs15)
	ERRSD(Is15)=ERR(IIs15)
	DO Js15=1,NMSD(Is15)
	SEEDs15(Is15,1,Js15)=MIU(IIs15,Js15)
	SEEDs15(Is15,2,Js15)=TAO(IIs15,Js15)
	END DO
	FLAGs15=1
	EXIT

	END IF
	END DO
	IIs15=IIs15+1
	END DO 

	OPT=ERRSD(1)
	No15=NMSD(1)
	DO Is15=1,No15
	Mo15(Is15)=SEEDs15(1,1,Is15)
	To15(Is15)=SEEDs15(1,2,Is15)
	END DO

S46:DO Is15=(SAMPLE/2)+1,SAMPLE		! SELECTION
 	CALL RANDOM_NUMBER(RNDs15)
	NMOD(Is15)=CEILING(RNDs15*(N0s15-2)+1.25)
	DO Js15=1,NMOD(Is15)     
	CALL RANDOM_NUMBER(RNDs15)
	MIU(Is15,Js15)=RNDs15*RA2s15+(1-RNDs15)*RA1s15
	IF (FLAGi15.EQ.0) THEN

08	CALL RANDOM_NUMBER(RNDs15)
	RSUMs15=RNDs15*tMAX+(1-RNDs15)*tMIN
	XCHMs15=0.
	DO IIs15=1,Js15-1
	XCHMs15(1,1,IIs15)=TAO(Is15,IIs15)
	END DO

	IIs15=Js15-1
	DO WHILE (IIs15.GT.0)
	IF (RSUMs15.EQ.XCHMs15(1,1,IIs15)) THEN
	GOTO 08
	END IF
	IF (RSUMs15.LT.XCHMs15(1,1,IIs15)) THEN
	XCHMs15(1,1,IIs15+1)=XCHMs15(1,1,IIs15)
	IF (IIs15.EQ.1) THEN
	XCHMs15(1,1,1)=RSUMs15
	END IF
	END IF
	IF (RSUMs15.GT.XCHMs15(1,1,IIs15)) THEN
	XCHMs15(1,1,IIs15+1)=RSUMs15
	EXIT
	END IF
	IIs15=IIs15-1
	END DO

	IF (Js15.EQ.1) THEN
	TAO(Is15,Js15)=RSUMs15
	ELSE
	DO IIs15=1,Js15
	TAO(Is15,IIs15)=XCHMs15(1,1,IIs15)
	END DO
	END IF

	ELSE
	TAO(Is15,Js15)=EXP((tMAX-tMIN)/N0s15*(Js15-0.5)+tMIN) 
	END IF
	END DO
	DO Js15=1,NMOD(Is15)
	TAO(Is15,Js15)=EXP(TAO(Is15,Js15))
	END DO
	END DO S46

	IIs15=NSEED
	DO WHILE (IIs15.GT.0)
  	CALL RANDOM_NUMBER(RNDs15)
    Ms15=CEILING(RNDs15*(SAMPLE/2.-1.)+0.25)+SAMPLE/2
    NMOD(Ms15)=NMSD(IIs15)
	DO Js15=1,NMOD(Ms15)
	MIU(Ms15,Js15)=SEEDs15(IIs15,1,Js15)
	TAO(Ms15,Js15)=SEEDs15(IIs15,2,Js15)
	END DO
	IIs15=IIs15-1
	END DO

S56:DO Is15=1,SAMPLE/2 	    ! CROSS-OVER 
	CALL RANDOM_NUMBER(RNDs15)
	IF (RNDs15.LE.PC) THEN

	DO IIs15=1,2
	LOCs15(IIs15)=2*Is15-2+IIs15
	END DO
	IF (NMOD(LOCs15(1)).LT.NMOD(LOCs15(2))) THEN
	Ms15=1
	ELSE
	Ms15=2
	END IF

	CALL RANDOM_NUMBER(RNDs15)
	PT1(Ms15)=CEILING(RNDs15*(NMOD(LOCs15(Ms15))-1.)+0.25)
	CALL RANDOM_NUMBER(RNDs15)
	PT2(Ms15)=CEILING(RNDs15*(NMOD(LOCs15(Ms15))-1.)+0.25)
	IF (PT1(Ms15).GT.PT2(Ms15)) THEN
	XCHs15=PT1(Ms15)
	PT1(Ms15)=PT2(Ms15)
	PT2(Ms15)=XCHs15
	END IF

	IF (PT1(Ms15).EQ.1) THEN
	IND1s15=tMIN
	ELSE
	IND1s15=(LOG(TAO(LOCs15(Ms15),PT1(Ms15)-1))+LOG(TAO(LOCs15(Ms15),PT1(Ms15))))/2.
	END IF
 	IF (PT2(Ms15).EQ.NMOD(LOCs15(Ms15))) THEN
	IND2s15=tMAX
	ELSE
	IND2s15=(LOG(TAO(LOCs15(Ms15),PT2(Ms15)))+LOG(TAO(LOCs15(Ms15),PT2(Ms15)+1)))/2.
	END IF

	FLAGs15=0
	DO Js15=1,NMOD(LOCs15(3-Ms15))
	IF ((TAO(LOCs15(3-Ms15),Js15).GE.EXP(IND1s15)).AND.(FLAGs15.EQ.0)) THEN
	PT1(3-Ms15)=Js15
	PT2(3-Ms15)=NMOD(LOCs15(3-Ms15))
	FLAGs15=1
	END IF
	IF ((TAO(LOCs15(3-Ms15),Js15).GT.EXP(IND2s15)).AND.(FLAGs15.EQ.1)) THEN
	PT2(3-Ms15)=Js15-1
	EXIT
	END IF
	END DO
	IF ((PT1(3-Ms15).GT.PT2(3-Ms15)).OR.(FLAGs15.EQ.0)) THEN
	GOTO 09
	END IF

	DO IIs15=1,2
	XCHs15=PT2(3-IIs15)-PT1(3-IIs15)-PT2(IIs15)+PT1(IIs15)
	IF (NMOD(LOCs15(IIs15))+XCHs15.EQ.1) THEN
	GOTO 09
	END IF
	END DO

	DO IIs15=1,2
	DO Js15=1,NMOD(LOCs15(IIs15))
	XCHMs15(IIs15,1,Js15)=MIU(LOCs15(IIs15),Js15)
 	XCHMs15(IIs15,2,Js15)=TAO(LOCs15(IIs15),Js15)
	END DO
	END DO

S57:DO IIs15=1,2
    JJs15=0	
	DO Js15=1,PT1(IIs15)-1
	JJs15=JJs15+1
	MIU(LOCs15(IIs15),JJs15)=XCHMs15(IIs15,1,Js15)
	TAO(LOCs15(IIs15),JJs15)=XCHMs15(IIs15,2,Js15)
	END DO

	DO Js15=PT1(3-IIs15),PT2(3-IIs15)
	JJs15=JJs15+1
	MIU(LOCs15(IIs15),JJs15)=XCHMs15(3-IIs15,1,Js15)
	TAO(LOCs15(IIs15),JJs15)=XCHMs15(3-IIs15,2,Js15)
	END DO

	DO Js15=PT2(IIs15)+1,NMOD(LOCs15(IIs15))
	JJs15=JJs15+1
	MIU(LOCs15(IIs15),JJs15)=XCHMs15(IIs15,1,Js15)
	TAO(LOCs15(IIs15),JJs15)=XCHMs15(IIs15,2,Js15)
	END DO
	NMOD(LOCs15(IIs15))=JJs15
	END DO S57

09	END IF

	END DO S56

S58:DO Is15=1,SAMPLE		  ! MUTATION

	DO Js15=1,NMOD(Is15)
	IF (Js15.EQ.1) THEN
	BDRs15(1,Js15)=tMIN
	ELSE
	BDRs15(1,Js15)=BDRs15(2,Js15-1)
	END IF
 	IF (Js15.EQ.NMOD(Is15)) THEN
	BDRs15(2,Js15)=tMAX
	ELSE
	BDRs15(2,Js15)=(LOG(TAO(Is15,Js15))+LOG(TAO(Is15,Js15+1)))/2.
	END IF
	END DO

	Js15=1
S59:DO WHILE (Js15.LE.NMOD(Is15))
	CALL RANDOM_NUMBER(RNDs15)
	IF (RNDs15.LE.PM) THEN

	FLAGs15=0
	IF (NMOD(Is15).LE.2) THEN
	FLAGs15=1
	END IF
	IF (NMOD(Is15).EQ.N0s15) THEN
	FLAGs15=-1
	END IF
	CALL RANDOM_NUMBER(RNDs15)
	IF ((RNDs15.LE.0.33).AND.(NMOD(Is15).GT.2).AND.(Js15.LT.NMOD(Is15))) THEN
 	FLAGs15=-1
	END IF
  	IF ((RNDs15.GT.0.66).AND.(NMOD(Is15).LT.N0s15)) THEN
 	FLAGs15=1
	END IF

    IF (FLAGs15.EQ.0) THEN
	CALL RANDOM_NUMBER(RNDs15)
	MIU(Is15,Js15)=RNDs15*RA2s15+(1-RNDs15)*RA1s15
    IF (FLAGi15.EQ.0) THEN
	CALL RANDOM_NUMBER(RNDs15)
	TAO(Is15,Js15)=EXP((BDRs15(2,Js15)-BDRs15(1,Js15))*RNDs15+BDRs15(1,Js15))
	END IF 
	END IF

	IF (FLAGs15.EQ.-1) THEN
	MIU(Is15,Js15)=MIU(Is15,Js15)+MIU(Is15,Js15+1)
	TAO(Is15,Js15)=EXP(BDRs15(2,Js15))
	DO JJs15=Js15+1,NMOD(Is15)-1
	MIU(Is15,JJs15)=MIU(Is15,JJs15+1)
	TAO(Is15,JJs15)=TAO(Is15,JJs15+1)
	END DO
	DO JJs15=Js15,NMOD(Is15)-1
	BDRs15(2,JJs15)=BDRs15(2,JJs15+1)
	END DO
	DO JJs15=Js15+1,NMOD(Is15)-1
	BDRs15(1,JJs15)=BDRs15(1,JJs15+1)
	END DO
	NMOD(Is15)=NMOD(Is15)-1
	END IF

	IF (FLAGs15.EQ.1) THEN
	R1s15=MIU(Is15,Js15)
	R2s15=TAO(Is15,Js15)
	JJs15=NMOD(Is15)
	DO WHILE (JJs15.GE.Js15+1)
 	MIU(Is15,JJs15+1)=MIU(Is15,JJs15)
 	TAO(Is15,JJs15+1)=TAO(Is15,JJs15)
  	BDRs15(1,JJs15+1)=BDRs15(1,JJs15)
  	BDRs15(2,JJs15+1)=BDRs15(2,JJs15)
	JJs15=JJs15-1
	END DO
	MIU(Is15,Js15)=R1s15/2.
	MIU(Is15,Js15+1)=R1s15/2.
	TAO(Is15,Js15)=SQRT(R2s15*EXP(BDRs15(1,Js15)))
	TAO(Is15,Js15+1)=SQRT(R2s15*EXP(BDRs15(2,Js15)))
	BDRs15(1,Js15+1)=LOG(R2s15)
	BDRs15(2,Js15+1)=BDRs15(2,Js15)
	BDRs15(2,Js15)=LOG(R2s15)
	NMOD(Is15)=NMOD(Is15)+1
	Js15=Js15+1
	END IF 

    END IF
	Js15=Js15+1
	END DO	S59
	END DO	S58

	OPT=0.							! *
	DO Is15=1,NUMG					! *
	GF(Is15)=0.						! *
	DO Js15=1,No15					! *
	R1s15=Mo15(Js15)-T(Is15)/To15(Js15)	! *
	IF (R1s15.GT.-20.) THEN			! *
    GF(Is15)=GF(Is15)+EXP(Mo15(Js15)-T(Is15)/To15(Js15)) ! *
	END IF							! *
	END DO							! *
	OPT=OPT+ABS(G(Is15)-GF(Is15))/G(Is15)	 ! *
	END DO							! *

	IF (MOD(Ks15,GENERATION).EQ.0) THEN
	WRITE(*,*) Ks15,' GENERATION FINISH',OPT/NUMG
	END IF

	IF (Ks15.GT.1) THEN
	IF ((OPT0-OPT)/OPT0.GT.0.01)	THEN
	COUNT=0
	PM=0.3
	PC=0.5
	ELSE
	COUNT=COUNT+1
	END IF
	IF (COUNT.GT.500) THEN
	PM=0.1
	PC=1.0
	END IF
	END IF
 	OPT0=OPT

	END DO S43

	ERRMo15=0.
	DO Is15=1,NUMG					! CALCULATE THE FITTING
	GF(Is15)=0.
	DO Js15=1,No15
	R1s15=Mo15(Js15)-T(Is15)/To15(Js15)
	IF (R1s15.GT.-20.) THEN
    GF(Is15)=GF(Is15)+EXP(Mo15(Js15)-T(Is15)/To15(Js15))
	END IF
	END DO
	ERRMo15=ERRMo15+ABS(G(Is15)-GF(Is15))/G(Is15)
	END DO

	ERRMo15=ERRMo15/NUMG

 	RETURN 

	END	SUBROUTINE GEAM

!==================================================================
!      SUBROUTINE 16: TESTING THE POSSIBLE ERROR
!==================================================================

	SUBROUTINE TSER(FLAGPi16,SIZi16,STRMAPi16,STRINFi16,STRPNTi16,STATo16)
 
	USE SHARED

	REAL :: MLs16,RSUMs16
    REAL, INTENT(IN) ::	STRPNTi16(505,1010),STRINFi16(505,5)
	INTEGER :: Is16,Js16,Ks16,SUMs16,CENs16
	INTEGER, INTENT(IN) :: SIZi16,STRMAPi16(505,20),FLAGPi16
	INTEGER, INTENT(OUT) :: STATo16

	STATo16=1

	IF (MOD(SIZi16-3,2).NE.0) THEN
	WRITE(*,*) 'ERROR TYPE 0'
	STATo16=-1
	RETURN
	END IF

	DO Is16=1,SIZi16
	DO Js16=1,2
	CENs16=(Js16-1)*(FUN-1)
	SUMs16=0
	DO Ks16=1,FUN-1
	IF (STRMAPi16(Is16,Ks16+CENs16).NE.0) THEN
	SUMs16=SUMs16+1
	END IF
	END DO
	IF (SUMs16.EQ.1) THEN
	WRITE(*,*) 'ERROR TYPE 1'
	STATo16=-1
	RETURN
	END IF
	END DO

	IF (STRMAPi16(Is16,2*FUN-1).EQ.0) THEN
	WRITE(*,*) 'ERROR TYPE 2'
	STATo16=-1
	RETURN
	END IF
	IF (STRMAPi16(Is16,2*FUN+1).NE.0) THEN
	WRITE(*,*) 'ERROR TYPE 15'
	STATo16=-1
	RETURN
	END IF

	END DO


!	RSUMs16=0.
!S50:DO Is16=1,SIZi16
!	DO Js16=1,2*FUN-1
!	IF (STRMAPi16(Is16,Js16).GT.SIZi16) THEN
!	WRITE(*,*) 'ERROR TYPE 3'
!	STATo16=-1
!	RETURN
!	END IF
!	END DO

!	SUMs16=0
!	DO Js16=1,2*(FUN-1)
!	IF (STRMAPi16(Is16,Js16).EQ.0) THEN
!	SUMs16=SUMs16+1
!	END IF
!	END DO
!	IF ((SUMs16.EQ.2*(FUN-1)).AND.(SIZi16.GT.1)) THEN
!	WRITE(*,*) 'ERROR TYPE 4'
!	STATo16=-1
!	RETURN
!	END IF

!	IF (ABS(STRINFi16(Is16,1)).GT.1.) THEN
!	WRITE(*,*) 'ERROR TYPE 5'
!	STATo16=-1
!	RETURN
!	END IF

!	IF (STRINFi16(Is16,1)+STRMAPi16(Is16,2*FUN).LT.0.) THEN
!	WRITE(*,*) 'ERROR TYPE 6'
!	STATo16=-1
!	RETURN
!	END IF

!	IF ((STRINFi16(Is16,1).EQ.0.).AND.(STRMAPi16(Is16,2*FUN).EQ.0)) THEN
!	WRITE(*,*) 'ERROR TYPE 7'
!	STATo16=-1
!	RETURN
!	END IF

!	RSUMs16=RSUMs16+STRINFi16(Is16,1)+STRMAPi16(Is16,2*FUN)
!	END DO	S50

!	IF (RSUMs16.LT.0.) THEN
!	WRITE(*,*) 'ERROR TYPE 8'
!	STATo16=-1
!	RETURN
!	END IF

!	IF (SIZi16.EQ.0) THEN
!	WRITE(*,*) 'ERROR TYPE 9'
!	STATo16=-1
!	RETURN
!	END	IF 

!	IF (FLAGPi16.EQ.1) THEN
!	DO Is16=1,SIZi16
!	MLs16=STRMAPi16(Is16,2*FUN)+STRINFi16(Is16,1)
!	DO Js16=1,STRMAPi16(Is16,2*FUN+1)
!	IF ((STRPNTi16(Is16,Js16).LT.0.).AND.(STRPNTi16(Is16,Js16).GT.MLs16)) THEN
!	WRITE(*,*) 'ERROR TYPE 10'
!	STATo16=-1
!	RETURN
!	END IF
!	END DO
!	END DO
!	END IF

!	DO Is16=1,NUM+NLF
!	IF (CEILING(LMAP(Is16,2)+FMAP(Is16,2)).LT.1) THEN
! 	WRITE(*,*) 'ERROR TYPE 11'
!	STATo16=-1
!	RETURN
!	END IF

!	IF (LMAP(Is16,6).EQ.2) THEN
! 	WRITE(*,*) 'ERROR TYPE 12'
!	STATo16=-1
!	RETURN
!	END IF
!	END DO

!	DO Is16=1,NUMSTR
!	IF (STRMAP(Is16,2*FUN)+STRINF(Is16,1).LT.0.) THEN
! 	WRITE(*,*) 'ERROR TYPE 13'
!	STATo16=-1
!	RETURN
!	END IF

! 	IF ((STRMAP(Is16,2*FUN).EQ.0).AND.(STRINF(Is16,1).EQ.0.)) THEN
! 	WRITE(*,*) 'ERROR TYPE 14',Is16,NUMSTR
!	STATo16=-1
!	RETURN
!	END IF
!	END DO

	RETURN

 	END	SUBROUTINE TSER

!==================================================================
!      SUBROUTINE 17: PRINT THE STRAND INFORMATION
!==================================================================

	SUBROUTINE PTER(FLAGPi17,NUMi17,SIZi17,STRMAPi17,STRINFi17,STRPNTi17)
 
	USE SHARED

    REAL, INTENT(IN) ::	STRPNTi17(505,1010),STRINFi17(505,5)
	INTEGER :: Is17,FLAGPi17,LENTHs17
	CHARACTER :: STRNGs17
	INTEGER, INTENT(IN) :: SIZi17,STRMAPi17(505,20),NUMi17

	WRITE(STRNGs17,'(I1)') NUMi17
	OPEN(40,FILE='TEST'//STRNGs17//'.DAT')

	WRITE(40,*)	'SIZE: ',SIZi17
	DO Is17=1,SIZi17
	WRITE(40,*)	STRMAPi17(Is17,2*FUN-1),': ',STRMAPi17(Is17,2*FUN),STRINFi17(Is17,1)
	WRITE(40,*)	STRMAPi17(Is17,1:2*FUN-2)
	END DO
	WRITE(40,*)
	DO Is17=1,SIZi17
	WRITE(40,*)	STRMAPi17(Is17,2*FUN-1),': ',STRMAPi17(Is17,2*FUN+1)
	IF (FLAGPi17.EQ.1) THEN
	LENTHs17=STRMAPi17(Is17,2*FUN+1)
	WRITE(40,*)	STRPNTi17(Is17,1:LENTHs17)
	END IF
	END DO

	CLOSE(40)

	RETURN 

	END	SUBROUTINE PTER

!==================================================================
!      SUBROUTINE 18: GET THE STRAND INFORMATION DOE BREAKAGE
!==================================================================

	SUBROUTINE BKINF(Mo18,NUMo18,STATo18)

	USE SHARED

	REAL :: RNDs18,FLENs18
	INTEGER :: Is18,Js18,SIZs18,LOCs18,LENTHs18
	INTEGER, INTENT(OUT) :: Mo18,NUMo18,STATo18

	STATo18=1

	DO Is18=1,NUM+NLF
	NUMo18=0
	LOCs18=LMAP(Is18,7)-1
	SIZs18=LMAP(Is18,6)
	DO Js18=1,SIZs18
	LENTHs18=STRMAP(LOCs18+Js18,2*FUN)
	FLENs18=STRINF(LOCs18+Js18,1)
	IF (LENTHs18+FLENs18.LE.STRMA) THEN
	NUMo18=NUMo18+LENTHs18
	ELSE
	STATo18=-1
	Mo18=Is18
 	CALL RANDOM_NUMBER(RNDs18)
	NUMo18=NUMo18+FLOOR(0.5*STRMA+RNDs18*(LENTHs18-0.5*STRMA))
	RETURN
	END IF
	END DO
	END DO

	RETURN 

	END	SUBROUTINE BKINF
